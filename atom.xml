<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jerry&#39;s Bolg</title>
  
  <subtitle>2B青年欢乐多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://oleaster.cn/"/>
  <updated>2018-04-03T05:58:16.396Z</updated>
  <id>http://oleaster.cn/</id>
  
  <author>
    <name>Q·Man</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx系列(7)第三方模块</title>
    <link href="http://oleaster.cn/2018/03/16/Nginx%E7%B3%BB%E5%88%977/"/>
    <id>http://oleaster.cn/2018/03/16/Nginx系列7/</id>
    <published>2018-03-16T02:46:12.000Z</published>
    <updated>2018-04-03T05:58:16.396Z</updated>
    
    <content type="html"><![CDATA[<font color="#0099ff" size="12" face="黑体">Nginx模块(二)</font><blockquote></blockquote><p>整合一些好的第三方模块及</p><hr><h1 id="模块文档"><a href="#模块文档" class="headerlink" title="模块文档"></a>模块文档</h1><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><ol><li>echo-nginx-module</li></ol><p>echo-nginx-module是一个第三方模块，在nginx源码中没有，但是OpenResty中有，它为nginx.conf带来了echo，sleep，time等多个类似bash的强大命令。<br>目前最新版本是v0.61</p><p>安装指南参见<br><a href="https://github.com/openresty/echo-nginx-module#installation" target="_blank" rel="noopener">https://github.com/openresty/echo-nginx-module#installation</a></p><p><strong> 配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">erver &#123;  </span><br><span class="line">    listen 8081;  </span><br><span class="line">    server_name localhost;  </span><br><span class="line">  </span><br><span class="line">    location /test/ &#123;  </span><br><span class="line">        set $foo hello;  </span><br><span class="line">        echo &quot;foo: $foo&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    location /test1/ &#123;  </span><br><span class="line">        set $first &quot;hello &quot;;  </span><br><span class="line">        echo &quot;$&#123;first&#125;world&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    location /foo/ &#123;  </span><br><span class="line">        echo &quot;foo = [$foo]&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    location /bar/ &#123;  </span><br><span class="line">        set $foo 32;   </span><br><span class="line">        echo &quot;bar = [$foo]&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 下载源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">git clone https://github.com/openresty/echo-nginx-module.git</span><br><span class="line"></span><br><span class="line">cd nginx-1.12.2</span><br><span class="line">./configure --with-http_ssl_module \</span><br><span class="line">--with-pcre=/usr/local/src/pcre-8.41 \</span><br><span class="line">--with-zlib=/usr/local/src/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/local/src/openssl-1.1.0g \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--add-module=/usr/local/src/ngx_cache_purge \</span><br><span class="line">--add-module=/usr/local/src/ngx_req_status \</span><br><span class="line">--add-module=/usr/local/src/echo-nginx-module</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>这个例子也给出了OpenResty中的模块如何编译进社区最新版nginx中去的方法。我起初看到OpenResty中的模块目录比较怪异，以为还需要自己调整目录结构再整合到nginx中，其实是没有必要的。</p><p>安装完成之后，检查nginx.conf的完整性并重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.1.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>测试请求</p><ol><li><p>curl -v ‘<a href="http://localhost:8081/test/&#39;" target="_blank" rel="noopener">http://localhost:8081/test/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.2.png" alt="测试结果1" title="">                </div>                <div class="image-caption">测试结果1</div>            </figure></li><li><p>curl -v ‘<a href="http://localhost:8081/test1/&#39;" target="_blank" rel="noopener">http://localhost:8081/test1/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.3.png" alt="测试结果2" title="">                </div>                <div class="image-caption">测试结果2</div>            </figure></li><li><p>curl -v ‘<a href="http://localhost:8081/foo/&#39;" target="_blank" rel="noopener">http://localhost:8081/foo/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.4.png" alt="测试结果3" title="">                </div>                <div class="image-caption">测试结果3</div>            </figure></li><li><p>curl -v ‘<a href="http://localhost:8081/bar/&#39;" target="_blank" rel="noopener">http://localhost:8081/bar/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.5.png" alt="测试结果4" title="">                </div>                <div class="image-caption">测试结果4</div>            </figure></li></ol><p>特殊说明</p><p>上面仅是最基本的用法，还有很多高级的用法.</p><hr><p><strong> 配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 8082;  </span><br><span class="line">    server_name localhost;  </span><br><span class="line">  </span><br><span class="line">    location /foo/ &#123;  </span><br><span class="line">        set $a hello;  </span><br><span class="line">        echo_exec /bar/;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    location /foo1/ &#123;  </span><br><span class="line">        set $a hello;  </span><br><span class="line">        rewrite ^ /bar/;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    location /bar/ &#123;  </span><br><span class="line">        echo &quot;a = [$a]&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更新nginx.conf之后，nginx -s reload</p><p>curl -v ‘<a href="http://localhost:8082/foo/&#39;" target="_blank" rel="noopener">http://localhost:8082/foo/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.6.png" alt="测试结果5" title="">                </div>                <div class="image-caption">测试结果5</div>            </figure><p>curl -v ‘<a href="http://localhost:8082/foo1/&#39;" target="_blank" rel="noopener">http://localhost:8082/foo1/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.7.png" alt="测试结果6" title="">                </div>                <div class="image-caption">测试结果6</div>            </figure><hr><p>下面是更进一步的例子</p><p>因为对内建变量 $args 的修改会直接导致当前请求的 URL 参数串发生变化，因此内建变量 $arg_XXX 自然也会随之变化。<br><strong> 配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /test3/ &#123;  </span><br><span class="line">    set $orig_a $arg_a;  </span><br><span class="line">    set $args &quot;a=5&quot;;  </span><br><span class="line">    echo &quot;original a: $orig_a&quot;;  </span><br><span class="line">    echo &quot;a: $arg_a&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更新nginx.conf之后，nginx -s reload</p><p>curl ‘<a href="http://localhost:8082/test3?a=3/&#39;" target="_blank" rel="noopener">http://localhost:8082/test3?a=3/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.8.png" alt="测试结果7" title="">                </div>                <div class="image-caption">测试结果7</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 8083;  </span><br><span class="line">    server_name localhost;  </span><br><span class="line">  </span><br><span class="line">    location /test/ &#123;  </span><br><span class="line">        set $args &quot;foo=1&amp;bar=2&quot;;  </span><br><span class="line">        proxy_pass http://127.0.0.1:8084/args/;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">server &#123;  </span><br><span class="line">    listen 8084;  </span><br><span class="line">    server_name localhost;  </span><br><span class="line">  </span><br><span class="line">    location /args/ &#123;  </span><br><span class="line">        echo &quot;args: $args&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新nginx.conf之后，nginx -s reload</p><p>curl -v ‘<a href="http://localhost:8083/test?blah=7/&#39;" target="_blank" rel="noopener">http://localhost:8083/test?blah=7/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.9.png" alt="测试结果8" title="">                </div>                <div class="image-caption">测试结果8</div>            </figure><hr><p>父子请求之间的变量共享</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /main/ &#123;  </span><br><span class="line">    echo_location /foo2/;  </span><br><span class="line">    echo_location /bar2/;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">location /foo2/ &#123;  </span><br><span class="line">    echo foo2;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">location /bar2/ &#123;  </span><br><span class="line">    echo bar2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>curl ‘<a href="http://localhost:8082/main/&#39;" target="_blank" rel="noopener">http://localhost:8082/main/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/2.0.png" alt="测试结果9" title="">                </div>                <div class="image-caption">测试结果9</div>            </figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location /main3/ &#123;  </span><br><span class="line">    set $var main;  </span><br><span class="line">    echo_location /foo3;  </span><br><span class="line">    echo_location /bar3;  </span><br><span class="line">    echo &quot;main: $var&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">location /foo3/ &#123;  </span><br><span class="line">    set $var foo;  </span><br><span class="line">    echo &quot;foo: $var&quot;;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">location /bar3/ &#123;  </span><br><span class="line">    set $var bar;  </span><br><span class="line">    echo &quot;bar: $var&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新nginx.conf之后，nginx -s reload<br>curl -v ‘<a href="http://localhost:8082/main3/&#39;" target="_blank" rel="noopener">http://localhost:8082/main3/&#39;</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/2.1.png" alt="测试结果10" title="">                </div>                <div class="image-caption">测试结果10</div>            </figure><p>参考文献<br>[1].<a href="https://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">https://github.com/openresty/echo-nginx-module</a><br>[2].<a href="http://blog.sina.com.cn/s/articlelist_1834459124_0_1.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/articlelist_1834459124_0_1.html</a></p><hr><ol><li>ngx_http_empty_gif_module<br>ngx_http_empty_gif_module是nginx自带的标准模块，它只返回一个保存在内存中的透明像素的GIF图片(速度当然比硬盘上读取的速度快很多)，多用于传递统计参数，用在location上下文中。<br>该模块默认就是开启的。<br>参考文献<br>[1].<a href="https://blog.csdn.net/tao_627/article/details/78971301" target="_blank" rel="noopener">https://blog.csdn.net/tao_627/article/details/78971301</a></li></ol><hr><ol><li>ngx_http_stub_status_module(标准模块)<br>增加对每请求的响应时间的统计：在stub status模块中增加了自Tengine启动以来所有请求的总响应时间(request_time)，</li></ol><p>参考文献<br>[1].<a href="https://blog.csdn.net/tao_627/article/details/78958455" target="_blank" rel="noopener">https://blog.csdn.net/tao_627/article/details/78958455</a><br>[2].<a href="https://blog.csdn.net/u010889990/article/details/42081973" target="_blank" rel="noopener">https://blog.csdn.net/u010889990/article/details/42081973</a></p><ol><li>ngx_req_status<br>ngx_req_status用来展示nginx请求状态信息，类似于apache的status，ats的stats_over_http和channel_stats，<br>nginx自带的模块只能显示连接数等等信息，我们并不能知道到底有哪些请求、以及各url域名所消耗的带宽是多少。</li></ol><p>ngx_req_status提供了这些功能：</p><ul><li>功能特性</li><li>按域名、url、ip等等统计信息</li><li>统计总流量</li><li>统计当前带宽\峰值带宽</li><li>统计总请求数量</li></ul><p>该模块的官网地址<br><a href="https://github.com/zls0424/ngx_req_status.git" target="_blank" rel="noopener">https://github.com/zls0424/ngx_req_status.git</a></p><p><strong> 下载源码并手动打补丁 </strong><br>下载它的源码，发现该模块源码比较早，最新的补丁是write_filter-1.7.11.patch，鉴于当前nginx的版本是1.12.2，最稳妥的方法是<br>参照该补丁文件，直接手动修改现在的相应源文件(行号相差不太远)<br>src/http/ngx_http_write_filter_module.c  第263行<br>相关声明在<br>src/http/ngx_http.h<br>src/http/ngx_http.c<br>src/http/ngx_http_core_module.h</p><p><strong> 编译</strong><br>下面开启编译该模块的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd nginx</span><br><span class="line">./configure --with-http_ssl_module \</span><br><span class="line">--with-pcre=/usr/local/src/pcre-8.41 \</span><br><span class="line">--with-zlib=/usr/local/src/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/local/src/openssl-1.1.0g \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--add-module=/usr/local/src/ngx_cache_purge \</span><br><span class="line">--add-module=/usr/local/src/ngx_req_status</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p><strong> 配置</strong><br>在nginx.conf的某个server块中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  </span><br><span class="line">    req_status_zone server_name $server_name     256k;  </span><br><span class="line">    req_status_zone server_addr $server_addr     256k;  </span><br><span class="line">    req_status_zone server_url  $server_name$uri 256k;  </span><br><span class="line">  </span><br><span class="line">    req_status server_name  server_addr  server_url;  </span><br><span class="line">  </span><br><span class="line">    server &#123;  </span><br><span class="line">        server_name localhost;  </span><br><span class="line">        location /ngx_req_status &#123;  </span><br><span class="line">            req_status_show on;  </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后检查nginx.conf语法合法性并重启nginx<br>/usr/local/nginx/sbin/nginx -t<br>/usr/local/nginx/sbin/nginx -s stop<br>/usr/local/nginx/sbin/nginx<br>注意重启并不会生效<br>/usr/local/nginx/sbin/nginx -s reload</p><p>指令解释<br>req_status_zone<br>语法: req_status_zone name string size<br>默认值: None<br>配置块: http<br>定义请求状态ZONE,请求按照string分组来排列，例如：<br>req_status_zone server_url  $server_name$uri 256k;<br>域名+uri将会形成一条数据，可以看到所有url的带宽，流量，访问数</p><p>req_status<br>语法: req_status zone1[ zone2]<br>默认值: None<br>配置块: http, server, location<br>在location中启用请求状态，你可以指定更多zones。</p><p>req_status_show<br>语法: req_status_show on<br>默认值: None<br>配置块: location</p><p><strong> 测试</strong><br>curl -v ‘<a href="http://127.0.0.1/ngx_req_status&#39;" target="_blank" rel="noopener">http://127.0.0.1/ngx_req_status&#39;</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/1.jpg" alt="测试结果" title="">                </div>                <div class="image-caption">测试结果</div>            </figure></p><hr><ol><li>set-misc-nginx-module<br>set-misc-nginx-module模块是标准的HttpRewriteModule指令的扩展，提供更多的功能，如URI转义与非转义、JSON引述、Hexadecimal/MD5/SHA1/Base32/Base64编码与解码、随机数等等。在后面的应用中，都将会接触使用到这个模块的。该模块是由章亦春先生开发的，他开发的其他模块应用也会使用到这个模块的。充分使用nginx非阻塞模式，对性能上有极大的提高，我个人认为很有必要去弄懂弄透nginx，通过自己去动手动脑用实例来加以验证，不断的对模块参数命令加以理解，在实际环境中应用自如。<br>这两个模块的主页分别是<br>标准模块ngx_http_rewrite_module<br><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_rewrite_module.html</a><br>第三方模块set-misc-nginx-module<br>ngx_set_misc - Various set_xxx directives added to nginx’s rewrite module (md5/sha1, sql/json quoting, and many more)<br><a href="https://github.com/openresty/set-misc-nginx-module" target="_blank" rel="noopener">https://github.com/openresty/set-misc-nginx-module</a></li></ol><p><strong> 下载源码</strong><br>cd /usr/local/src<br>wget <a href="https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz" target="_blank" rel="noopener">https://github.com/openresty/set-misc-nginx-module/archive/v0.31.tar.gz</a><br>wget <a href="https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz" target="_blank" rel="noopener">https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz</a><br>tar zxvf v0.31.tar.gz<br>tar zxvf v0.3.0.tar.gz</p><p><strong> 编译安装</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd nginx</span><br><span class="line">./configure --with-http_ssl_module \</span><br><span class="line">--with-pcre=/usr/local/src/pcre-8.41 \</span><br><span class="line">--with-zlib=/usr/local/src/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/local/src/openssl-1.1.0g \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--add-module=/usr/local/src/ngx_cache_purge \</span><br><span class="line">--add-module=/usr/local/src/ngx_req_status \</span><br><span class="line">--add-module=/usr/local/src/echo-nginx-module \</span><br><span class="line">--add-module=/usr/local/src/ngx_devel_kit-0.3.0 \</span><br><span class="line">--add-module=/usr/local/src/set-misc-nginx-module-0.31</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>注意这里set-misc-nginx-module依赖ngx_devel_kit模块，且–add-module=ngx_devel_kit一定要早于–add-module=set-misc-nginx-module</p><p><strong> 配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;  </span><br><span class="line">    echo &quot;uri = $uri&quot;;  </span><br><span class="line">    echo &quot;request_uri = $request_uri&quot;;  </span><br><span class="line">    echo &quot;name: $arg_name&quot;;  </span><br><span class="line">    echo &quot;class: $arg_class&quot;;  </span><br><span class="line">    set_unescape_uri $name $arg_name;  </span><br><span class="line">    set_unescape_uri $class $arg_class;  </span><br><span class="line">    echo &quot;name: $name&quot;;  </span><br><span class="line">    echo &quot;class: $class&quot;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 测试</strong><br>curl -v ‘<a href="http://localhost:8082/test&#39;" target="_blank" rel="noopener">http://localhost:8082/test&#39;</a><br>curl ‘<a href="http://localhost:8082/test?a=3&amp;b=4&#39;" target="_blank" rel="noopener">http://localhost:8082/test?a=3&amp;b=4&#39;</a><br>curl ‘<a href="http://localhost:8082/test/hello%20world?a=3&amp;b=4&#39;" target="_blank" rel="noopener">http://localhost:8082/test/hello%20world?a=3&amp;b=4&#39;</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/22.png" alt="测试结果1" title="">                </div>                <div class="image-caption">测试结果1</div>            </figure></p><hr><p>curl ‘<a href="http://localhost:8082/test?name=Tom&amp;class=3&#39;" target="_blank" rel="noopener">http://localhost:8082/test?name=Tom&amp;class=3&#39;</a><br>curl ‘<a href="http://localhost:8082/test?name=hello%20world&amp;class=9&#39;" target="_blank" rel="noopener">http://localhost:8082/test?name=hello%20world&amp;class=9&#39;</a><br>curl ‘<a href="http://localhost:8082/test?NAME=Marry&#39;" target="_blank" rel="noopener">http://localhost:8082/test?NAME=Marry&#39;</a><br>curl ‘<a href="http://localhost:8082/test?Name=Jimmy&#39;" target="_blank" rel="noopener">http://localhost:8082/test?Name=Jimmy&#39;</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/33.png" alt="测试结果2" title="">                </div>                <div class="image-caption">测试结果2</div>            </figure></p><hr><p>curl ‘<a href="http://localhost:8082/test?name=hello%20world&amp;class=9&#39;" target="_blank" rel="noopener">http://localhost:8082/test?name=hello%20world&amp;class=9&#39;</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/ThirdModule/44.png" alt="测试结果3" title="">                </div>                <div class="image-caption">测试结果3</div>            </figure></p><p>更复杂的指令待后续继续补充</p><ol><li>ngx_http_v2_module</li></ol><p>在原有基础上修改编译选项来开启http2</p><p>参考文献<br>[1].<a href="https://blog.csdn.net/tao_627/article/details/77266705" target="_blank" rel="noopener">https://blog.csdn.net/tao_627/article/details/77266705</a></p><ol><li>实现第一个自定义nginx模块</li></ol><p>参考文献<br><a href="https://blog.csdn.net/tao_627/article/details/60957718" target="_blank" rel="noopener">https://blog.csdn.net/tao_627/article/details/60957718</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;#0099ff&quot; size=&quot;12&quot; face=&quot;黑体&quot;&gt;Nginx模块(二)&lt;/font&gt;

&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;整合一些好的第三方模块及&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;模块文档&quot;&gt;&lt;a href=&quot;#模块文
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx系列(5)配置详解</title>
    <link href="http://oleaster.cn/2018/03/16/Nginx%E7%B3%BB%E5%88%975/"/>
    <id>http://oleaster.cn/2018/03/16/Nginx系列5/</id>
    <published>2018-03-16T02:46:12.000Z</published>
    <updated>2018-03-28T06:16:11.041Z</updated>
    
    <content type="html"><![CDATA[<font color="#0099ff" size="12" face="黑体">Nginx配置文件详解</font><p>Nginx配置分为各个配置块，主配置块负责全局配置，子配置块可以继承全局配置，也可以相应的配置不同设置。</p><ol><li>运行必备的配置</li><li>优化性能的配置</li><li>调试及定位问题的配置</li><li>事件驱动相关配置</li></ol><p>http协议配置块位于总体配置块中</p><ol><li>与套结字相关的配置</li><li>定义路径相关的配置</li><li>定义客户端请求的相关配置</li><li>对客户端进行限制的相关配置</li></ol><p>nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line">######Nginx配置文件nginx.conf中文详解#####</span><br><span class="line"></span><br><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user www www;</span><br><span class="line"></span><br><span class="line">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="line">worker_processes 8;</span><br><span class="line"> </span><br><span class="line">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">error_log /usr/local/nginx/logs/error.log info;</span><br><span class="line"># error_log /usr/local/nginx/logs/error.log info</span><br><span class="line"></span><br><span class="line">#进程pid文件</span><br><span class="line">pid /usr/local/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">#指定进程可以打开的最大描述符：数目</span><br><span class="line">#工作模式与连接数上限</span><br><span class="line">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="line">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span><br><span class="line">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><br><span class="line">    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">    #补充说明：</span><br><span class="line">    #与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br><span class="line">    #A）标准事件模型</span><br><span class="line">    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br><span class="line">    #B）高效事件模型</span><br><span class="line">    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br><span class="line">    #Epoll：使用于Linux内核2.6版本及以后的系统。</span><br><span class="line">    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br><span class="line">    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    #单个进程最大连接数（最大连接数=连接数*进程数）</span><br><span class="line">    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br><span class="line">    worker_connections 65535;</span><br><span class="line"></span><br><span class="line">    #keepalive超时时间。</span><br><span class="line">    keepalive_timeout 60;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br><span class="line">    #分页大小可以用命令getconf PAGESIZE 取得。</span><br><span class="line">    #[root@web001 ~]# getconf PAGESIZE</span><br><span class="line">    #4096</span><br><span class="line">    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">    open_file_cache max=65535 inactive=60s;</span><br><span class="line"></span><br><span class="line">    #这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br><span class="line">    open_file_cache_valid 80s;</span><br><span class="line"></span><br><span class="line">    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br><span class="line">    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br><span class="line">    open_file_cache_min_uses 1;</span><br><span class="line">    </span><br><span class="line">    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">    # 基础配置</span><br><span class="line">    ##</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include mime.types;</span><br><span class="line"></span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #默认编码</span><br><span class="line">    #charset utf-8;</span><br><span class="line"></span><br><span class="line">    #服务器名字的hash表大小</span><br><span class="line">    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"># server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line"></span><br><span class="line">    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line"></span><br><span class="line">    #设定通过nginx上传文件的大小</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line"></span><br><span class="line">    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br><span class="line">    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br><span class="line">    sendfile on;</span><br><span class="line"></span><br><span class="line">    #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">    autoindex on;</span><br><span class="line"></span><br><span class="line">    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">     </span><br><span class="line">    tcp_nodelay on;</span><br><span class="line"></span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout 120;</span><br><span class="line"></span><br><span class="line">    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #gzip模块设置</span><br><span class="line">    gzip on; #开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k;    #最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k;    #压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2;    #压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    #开启限制IP连接数的时候需要使用</span><br><span class="line">    #limit_zone crawler $binary_remote_addr 10m;</span><br><span class="line"></span><br><span class="line">#虚拟主机配置</span><br><span class="line">#include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    #负载均衡配置</span><br><span class="line">    upstream piao.jd.com &#123;</span><br><span class="line">     </span><br><span class="line">        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line"></span><br><span class="line">        #nginx的upstream目前支持4种方式的分配</span><br><span class="line">        #1、轮询（默认）</span><br><span class="line">        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">        #2、weight</span><br><span class="line">        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    server 192.168.0.14 weight=10;</span><br><span class="line">        #    server 192.168.0.15 weight=10;</span><br><span class="line">        #&#125;</span><br><span class="line">        #2、ip_hash</span><br><span class="line">        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">        #例如：</span><br><span class="line">        #upstream bakend &#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 192.168.0.14:88;</span><br><span class="line">        #    server 192.168.0.15:80;</span><br><span class="line">        #&#125;</span><br><span class="line">        #3、fair（第三方）</span><br><span class="line">        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server server1;</span><br><span class="line">        #    server server2;</span><br><span class="line">        #    fair;</span><br><span class="line">        #&#125;</span><br><span class="line">        #4、url_hash（第三方）</span><br><span class="line">        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line">        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line">        #upstream backend &#123;</span><br><span class="line">        #    server squid1:3128;</span><br><span class="line">        #    server squid2:3128;</span><br><span class="line">        #    hash $request_uri;</span><br><span class="line">        #    hash_method crc32;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        #tips:</span><br><span class="line">        #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br><span class="line">        #    ip_hash;</span><br><span class="line">        #    server 127.0.0.1:9090 down;</span><br><span class="line">        #    server 127.0.0.1:8080 weight=2;</span><br><span class="line">        #    server 127.0.0.1:6060;</span><br><span class="line">        #    server 127.0.0.1:7070 backup;</span><br><span class="line">        #&#125;</span><br><span class="line">        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><span class="line"></span><br><span class="line">        #每个设备的状态设置为:</span><br><span class="line">        #1.down表示单前的server暂时不参与负载</span><br><span class="line">        #2.weight为weight越大，负载的权重就越大。</span><br><span class="line">        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">        #4.fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line">        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br><span class="line">        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br><span class="line">        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    #虚拟主机的配置</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        #监听端口</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        #域名可以有多个，用空格隔开</span><br><span class="line">        server_name www.jd.com jd.com;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">        root /data/www/jd;</span><br><span class="line"></span><br><span class="line">        #对******进行负载均衡</span><br><span class="line">        location ~ .*.(php|php5)?$</span><br><span class="line">        &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            include fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #图片缓存时间设置</span><br><span class="line">        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 10d;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #日志格式设定</span><br><span class="line">        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br><span class="line">        #$remote_user：用来记录客户端用户名称；</span><br><span class="line">        #$time_local： 用来记录访问时间与时区；</span><br><span class="line">        #$request： 用来记录请求的url与http协议；</span><br><span class="line">        #$status： 用来记录请求状态；成功是200，</span><br><span class="line">        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br><span class="line">        #$http_referer：用来记录从那个页面链接访问过来的；</span><br><span class="line">        #$http_user_agent：记录客户浏览器的相关信息；</span><br><span class="line">        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br><span class="line">        log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">        &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">        &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;;</span><br><span class="line">         </span><br><span class="line">        #定义本虚拟主机的访问日志</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.404.log  log404;</span><br><span class="line">         </span><br><span class="line">        #对 &quot;/&quot; 启用反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             </span><br><span class="line">            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             </span><br><span class="line">            #以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">            #允许客户端请求的最大单文件字节数</span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">            #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br><span class="line">            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br><span class="line">            client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">            #表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class="line">            proxy_intercept_errors on;</span><br><span class="line"></span><br><span class="line">            #后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">            #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line"></span><br><span class="line">            #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line"></span><br><span class="line">            #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line"></span><br><span class="line">            #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br><span class="line">            proxy_buffer_size 4k;</span><br><span class="line"></span><br><span class="line">            #proxy_buffers缓冲区，网页平均在32k以下的设置</span><br><span class="line">            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class="line">            proxy_buffers 4 32k;</span><br><span class="line"></span><br><span class="line">            #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line"></span><br><span class="line">            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class="line">            #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log on;</span><br><span class="line">            auth_basic &quot;NginxStatus&quot;;</span><br><span class="line">            auth_basic_user_file confpasswd;</span><br><span class="line">            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #本地动静分离反向代理配置</span><br><span class="line">        #所有jsp的页面均交由tomcat或resin处理</span><br><span class="line">        location ~ .(jsp|jspx|do)?$ &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        #所有静态文件由nginx直接读取不经过tomcat或resin</span><br><span class="line">        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br><span class="line">        pdf|xls|mp3|wma)$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 15d; </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        location ~ .*.(js|css)?$</span><br><span class="line">        &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">######Nginx配置文件nginx.conf中文详解#####</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;#0099ff&quot; size=&quot;12&quot; face=&quot;黑体&quot;&gt;Nginx配置文件详解&lt;/font&gt;

&lt;p&gt;Nginx配置分为各个配置块，主配置块负责全局配置，子配置块可以继承全局配置，也可以相应的配置不同设置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行必备的配置&lt;/
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx系列(6)模块</title>
    <link href="http://oleaster.cn/2018/03/16/Nginx%E7%B3%BB%E5%88%976/"/>
    <id>http://oleaster.cn/2018/03/16/Nginx系列6/</id>
    <published>2018-03-16T02:46:12.000Z</published>
    <updated>2018-03-28T07:35:36.632Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#0099ff" size="12" face="黑体">Nginx模块(一)</font><br>此文摘至<a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a></p><blockquote></blockquote><p>Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。<br>Tengine的性能和稳定性已经在大型的网站如淘宝网，天猫商城等得到了很好的检验。<br>它的最终目标是打造一个高效、稳定、安全、易用的Web平台。</p><p>从2011年12月开始，Tengine成为一个开源项目，Tengine团队在积极地开发和维护着它。<br>Tengine团队的核心成员来自于淘宝、搜狗等互联网企业。<br>Tengine完全兼容Nginx，因此可以参照Tengine的方式来配置Nginx。</p><blockquote><p>可以说是Tengine是Nginx的分支 <code>备注</code></p></blockquote><p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx新增的模块</a></p><p><a href="http://nginx.org/en/docs/varindex.html" target="_blank" rel="noopener">Nginx新增的变量</a></p><p><a href="http://nginx.org/en/docs/dirindex.html" target="_blank" rel="noopener">Nginx新增的目录</a></p><p><a href="http://tengine.taobao.org/nginx_docs/cn/docs/" target="_blank" rel="noopener">Tengine翻译</a></p><hr><h1 id="模块文档"><a href="#模块文档" class="headerlink" title="模块文档"></a>模块文档</h1><h2 id="主功能"><a href="#主功能" class="headerlink" title="主功能"></a><a href="http://tengine.taobao.org/document_cn/core_cn.html" target="_blank" rel="noopener">主功能</a></h2><h2 id="HTTP核心模块"><a href="#HTTP核心模块" class="headerlink" title="HTTP核心模块"></a><a href="http://tengine.taobao.org/document_cn/http_core_cn.html" target="_blank" rel="noopener">HTTP核心模块</a></h2><h2 id="动态加载模块功能"><a href="#动态加载模块功能" class="headerlink" title="动态加载模块功能"></a><a href="http://tengine.taobao.org/document_cn/dso_cn.html" target="_blank" rel="noopener">动态加载模块功能</a></h2><h2 id="Dyups模块"><a href="#Dyups模块" class="headerlink" title="Dyups模块"></a><a href="http://tengine.taobao.org/document_cn/http_dyups_cn.html" target="_blank" rel="noopener">Dyups模块</a></h2><h2 id="SPDY模块功能"><a href="#SPDY模块功能" class="headerlink" title="SPDY模块功能"></a><a href="http://tengine.taobao.org/document_cn/ngx_http_spdy_module_cn.html" target="_blank" rel="noopener">SPDY模块功能</a></h2><h2 id="独立进程模块功能"><a href="#独立进程模块功能" class="headerlink" title="独立进程模块功能"></a><a href="http://tengine.taobao.org/document_cn/proc_cn.html" target="_blank" rel="noopener">独立进程模块功能</a></h2><h2 id="backtrace模块功能"><a href="#backtrace模块功能" class="headerlink" title="backtrace模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_backtrace_cn.html" target="_blank" rel="noopener">backtrace模块功能</a></h2><h2 id="concat模块功能"><a href="#concat模块功能" class="headerlink" title="concat模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_concat_cn.html" target="_blank" rel="noopener">concat模块功能</a></h2><h2 id="trim-filter模块功能"><a href="#trim-filter模块功能" class="headerlink" title="trim filter模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_trim_filter_cn.html" target="_blank" rel="noopener">trim filter模块功能</a></h2><h2 id="Upstream域名解析模块功能"><a href="#Upstream域名解析模块功能" class="headerlink" title="Upstream域名解析模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_dynamic_cn.html" target="_blank" rel="noopener">Upstream域名解析模块功能</a></h2><h2 id="headers模块功能"><a href="#headers模块功能" class="headerlink" title="headers模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_headers_cn.html" target="_blank" rel="noopener">headers模块功能</a></h2><h2 id="footer-filter模块功能"><a href="#footer-filter模块功能" class="headerlink" title="footer filter模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_footer_filter_cn.html" target="_blank" rel="noopener">footer filter模块功能</a></h2><h2 id="limit-req模块功能"><a href="#limit-req模块功能" class="headerlink" title="limit_req模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_limit_req_cn.html" target="_blank" rel="noopener">limit_req模块功能</a></h2><h2 id="limit-upstream-tries功能"><a href="#limit-upstream-tries功能" class="headerlink" title="limit upstream tries功能"></a><a href="http://tengine.taobao.org/document_cn/ngx_limit_upstream_tries_cn.html" target="_blank" rel="noopener">limit upstream tries功能</a></h2><h2 id="log模块功能"><a href="#log模块功能" class="headerlink" title="log模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_log_cn.html" target="_blank" rel="noopener">log模块功能</a></h2><h2 id="reqstat模块功能"><a href="#reqstat模块功能" class="headerlink" title="reqstat模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_reqstat_cn.html" target="_blank" rel="noopener">reqstat模块功能</a></h2><h2 id="lua模块-v0-7-19"><a href="#lua模块-v0-7-19" class="headerlink" title="lua模块(v0.7.19)"></a><a href="https://github.com/chaoslawful/lua-nginx-module/blob/master/README.markdown" target="_blank" rel="noopener">lua模块(v0.7.19)</a></h2><h2 id="ssl模块功能"><a href="#ssl模块功能" class="headerlink" title="ssl模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_ssl_cn.html" target="_blank" rel="noopener">ssl模块功能</a></h2><h2 id="stub-status模块功能"><a href="#stub-status模块功能" class="headerlink" title="stub_status模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_stub_status_cn.html" target="_blank" rel="noopener">stub_status模块功能</a></h2><h2 id="TFS模块功能"><a href="#TFS模块功能" class="headerlink" title="TFS模块功能"></a><a href="https://github.com/alibaba/nginx-tfs/blob/master/ReadMe.markdown" target="_blank" rel="noopener">TFS模块功能</a></h2><h2 id="sysguard模块功能"><a href="#sysguard模块功能" class="headerlink" title="sysguard模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_sysguard_cn.html" target="_blank" rel="noopener">sysguard模块功能</a></h2><h2 id="一致性hash模块功能"><a href="#一致性hash模块功能" class="headerlink" title="一致性hash模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_consistent_hash_cn.html" target="_blank" rel="noopener">一致性hash模块功能</a></h2><h2 id="session-sticky模块功能"><a href="#session-sticky模块功能" class="headerlink" title="session_sticky模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_session_sticky_cn.html" target="_blank" rel="noopener">session_sticky模块功能</a></h2><h2 id="健康检查模块功能"><a href="#健康检查模块功能" class="headerlink" title="健康检查模块功能"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="noopener">健康检查模块功能</a></h2><h2 id="后端长连接超时功能"><a href="#后端长连接超时功能" class="headerlink" title="后端长连接超时功能"></a><a href="http://tengine.taobao.org/document_cn/http_upstream_keepalive_timeout_cn.html" target="_blank" rel="noopener">后端长连接超时功能</a></h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><a href="http://tengine.taobao.org/document_cn/variables_cn.html" target="_blank" rel="noopener">变量</a></h2><h2 id="debug-pool模块"><a href="#debug-pool模块" class="headerlink" title="debug pool模块"></a><a href="http://tengine.taobao.org/document_cn/ngx_debug_pool_cn.html" target="_blank" rel="noopener">debug pool模块</a></h2><h2 id="slab-stat模块"><a href="#slab-stat模块" class="headerlink" title="slab stat模块"></a><a href="http://tengine.taobao.org/document_cn/ngx_slab_stat_cn.html" target="_blank" rel="noopener">slab stat模块</a></h2><h2 id="异步openssl模块"><a href="#异步openssl模块" class="headerlink" title="异步openssl模块"></a><a href="http://tengine.taobao.org/document_cn/ngx_http_ssl_asynchronous_mode_cn.html" target="_blank" rel="noopener">异步openssl模块</a></h2><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;#0099ff&quot; size=&quot;12&quot; face=&quot;黑体&quot;&gt;Nginx模块(一)&lt;/font&gt;&lt;br&gt;此文摘至&lt;a href=&quot;http://tengine.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Te
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx系列(4)配置</title>
    <link href="http://oleaster.cn/2018/03/15/Nginx%E7%B3%BB%E5%88%974/"/>
    <id>http://oleaster.cn/2018/03/15/Nginx系列4/</id>
    <published>2018-03-15T02:46:12.000Z</published>
    <updated>2018-03-28T06:15:54.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1><p>在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器<br>这三个不同的功能的使用，都跟nginx的配置密切相关，nginx服务器的配置信息主要集中在nginx.conf这个配置文件中，<br>在文件尾通过include /etc/nginx/conf.d/*.conf引入了default.conf配置<br>整个配置上下文分http、server和location三个层级，分别对应着http请求的全局性配置、server级配置和请求路径级配置。<br>nginx.conf负责http请求的全局配置，default.conf负责具体server及其下具体location的配置。这里为了方便是整合到一起的,<br>并且所有的可配置选项大致分为以下几个部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">main                                # 全局配置</span><br><span class="line"></span><br><span class="line">events &#123;                            # nginx工作模式配置</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;                                # http设置</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    server &#123;                        # 服务器主机配置</span><br><span class="line">        ....</span><br><span class="line">        location &#123;                    # 路由配置</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location path &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location otherpath &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        location &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream name &#123;                    # 负载均衡配置</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上述配置文件所示，主要由6个部分组成：</p><ol><li>main：用于进行nginx全局信息的配置</li><li>events：用于nginx工作模式的配置</li><li>http：用于进行http协议信息的一些配置</li><li>server：用于进行服务器访问信息的配置</li><li>ocation：用于进行访问路由的配置</li><li>upstream：用于进行负载均衡的配置</li></ol><h2 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h2><p>main模块是存放在main全局配置模块中的配置项</p><h2 id="event-模块"><a href="#event-模块" class="headerlink" title="event 模块"></a>event 模块</h2><p>event模块是针对nginx服务器的工作模式的一些操作配置</p><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>http模块是作为web服务器，http模块是nginx最核心的一个模块，配置项也是比较多的，项目中会设置到很多的实际业务场景，需要根据硬件信息进行适当的配置，常规情况下，使用默认配置即可！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ##</span><br><span class="line">    # 基础配置</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # SSL证书配置[可在Server或location继承]</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # 日志配置[可在Server或location继承]</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # Gzip 压缩配置[可在Server或location继承]</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    ##</span><br><span class="line">    # 虚拟主机配置[可在Server或location继承]</span><br><span class="line">    ##</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/nginx/sites-enabled/*;</span><br></pre></td></tr></table></figure><h2 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a>server模块</h2><p>server模块是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息</p><h2 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h2><p>location模块是nginx配置中出现最多的一个配置，主要用于配置路由访问信息</p><p>在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location模块也是一个非常重要的配置模块</p><h2 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h2><p>upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx配置&quot;&gt;&lt;a href=&quot;#Nginx配置&quot; class=&quot;headerlink&quot; title=&quot;Nginx配置&quot;&gt;&lt;/a&gt;Nginx配置&lt;/h1&gt;&lt;p&gt;在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器&lt;br&gt;这三个不同的功能的使用，
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx系列(3)日常维护常用命令</title>
    <link href="http://oleaster.cn/2018/03/14/Nginx%E7%B3%BB%E5%88%973/"/>
    <id>http://oleaster.cn/2018/03/14/Nginx系列3/</id>
    <published>2018-03-14T02:46:12.000Z</published>
    <updated>2018-03-28T06:15:40.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx日常维护常用命令"><a href="#Nginx日常维护常用命令" class="headerlink" title="Nginx日常维护常用命令"></a><font color="#0099ff" size="12" face="黑体">Nginx日常维护常用命令</font></h2><p><strong> 一、简明nginx常用命令 </strong></p><h1 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h1><blockquote><p>poechant@ubuntu:sudo ./sbin/nginx</p></blockquote><hr><h1 id="停止-Nginx"><a href="#停止-Nginx" class="headerlink" title="停止 Nginx"></a>停止 Nginx</h1><blockquote><p>poechant@ubuntu:sudo ./sbin/nginx -s stop<br>poechant@ubuntu:sudo ./sbin/nginx -s quit</p></blockquote><p>-s都是采用向 Nginx 发送信号的方式。</p><hr><h1 id="Nginx-重载配置"><a href="#Nginx-重载配置" class="headerlink" title="Nginx 重载配置"></a>Nginx 重载配置</h1><blockquote><p>poechant@ubuntu:sudo ./sbin/nginx -s reload<br>上述是采用向 Nginx 发送信号的方式，或者使用：<br>poechant@ubuntu:service nginx reload</p></blockquote><hr><h1 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h1><blockquote><p>poechant@ubuntu:sudo ./sbin/nginx -c /usr/local/nginx/conf/nginx.conf</p></blockquote><p>-c表示configuration，指定配置文件。</p><hr><h1 id="查看-Nginx-版本"><a href="#查看-Nginx-版本" class="headerlink" title="查看 Nginx 版本"></a>查看 Nginx 版本</h1><p>有两种可以查看 Nginx 的版本信息的参数。第一种如下：</p><blockquote><p>poechant@ubuntu:/usr/local/nginx$ ./sbin/nginx -v<br>nginx: nginx version: nginx/1.0.0</p></blockquote><p>另一种显示的是详细的版本信息：</p><blockquote><p>poechant@ubuntu:/usr/local/nginx$ ./sbin/nginx -V<br>nginx: nginx version: nginx/1.0.0<br>nginx: built by gcc 4.3.3 (Ubuntu 4.3.3-5ubuntu4)<br>nginx: TLS SNI support enabled<br>nginx: configure arguments: –with-http_ssl_module –with-openssl=/home/luming/openssl-1.0.0d/</p></blockquote><hr><h1 id="检查配置文件是否正确"><a href="#检查配置文件是否正确" class="headerlink" title="检查配置文件是否正确"></a>检查配置文件是否正确</h1><blockquote><p>poechant@ubuntu:/usr/local/nginx$ ./sbin/nginx -t<br>nginx: [alert] could not open error log file: open() “/usr/local/nginx/logs/error.log” failed (13: Permission denied)<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>2012/01/09 16:45:09 [emerg] 23898#0: open() “/usr/local/nginx/logs/nginx.pid” failed (13: Permission denied)<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test failed</p></blockquote><p>如果出现如上的提示信息，表示没有访问错误日志文件和进程，可以sudo（super user do）一下：</p><blockquote><p>poerchant@ubuntu:/usr/local/nginx$ sudo ./sbin/nginx -t<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</p></blockquote><p>如果显示如上，则表示配置文件正确。否则，会有相关提示。</p><hr><h1 id="显示帮助信息"><a href="#显示帮助信息" class="headerlink" title="显示帮助信息"></a>显示帮助信息</h1><blockquote><p>poechant@ubuntu:/user/local/nginx$ ./sbin/nginx -h</p></blockquote><p>或者：</p><blockquote><p>poechant@ubuntu:/user/local/nginx$ ./sbin/nginx -?</p></blockquote><p>以上这些涵盖了 Nginx 日常维护的所有基本操作.</p><hr><p><strong> 二、在Linux下通过master发送信号的相关命令 </strong></p><h1 id="停止操作"><a href="#停止操作" class="headerlink" title="停止操作"></a>停止操作</h1><p>停止操作是通过向nginx进程发送信号（什么是信号请参阅linux文章）来进行的</p><ol><li>查询nginx主进程号<br>ps -ef | grep nginx<br>在进程列表里面找master进程，它的编号就是主进程号了。</li><li><p>检查是否已经安装有nginx及对应目录：<br>[root@localhost ~]# find /|grep nginx.conf<br>/etc/nginx/conf.d<br>/etc/nginx/conf.d/example_ssl.conf<br>/etc/nginx/conf.d/default.conf<br>/etc/nginx/nginx.conf<br> 还可以用以下两个命令，找安装的路径<br> [root@localhost ~]# netstat -tnlp|grep nginx<br> 然后看到一行记录，复制最后的一个数据（进程ID）<br> ps -aux |grep 进程ID<br> 就可以看到nginx的启动方式了。</p></li><li><p>发送信号<br>从容停止Nginx：<br>kill -QUIT 主进程号<br>快速停止Nginx：<br>kill -TERM 主进程号<br>强制停止Nginx：<br>pkill -9 nginx<br>另外， 若在nginx.conf配置了pid文件存放路径则该文件存放的就是Nginx主进程号，如果没指定则放在nginx的logs目录下。有了pid文 件，我们就不用先查询Nginx的主进程号，而直接向Nginx发送信号了，命令如下：<br>kill -信号类型 ‘/usr/nginx/logs/nginx.pid’ <code>(推荐)</code><br><strong> 平滑重启</strong><br>如果更改了配置就要重启Nginx，要先关闭Nginx再打开？不是的，可以向Nginx 发送信号，平滑重启。<br>平滑重启命令：<br>kill -HUP 住进称号或进程号文件路径<br>或者使用<br>复制代码 代码如下:<br><strong><em> nginx -s reload </em></strong> <code>(推荐)</code><br>或<br>/usr/nginx/sbin/nginx -s reload<br>注意，修改了配置文件后最好先检查一下修改过的配置文件是否正 确，以免重启后Nginx出现错误影响服务器稳定运行。判断Nginx配置是否正确命令如下：<br>nginx -t -c /usr/nginx/conf/nginx.conf<br>或者<br><strong><em> nginx -t </em></strong> <code>(推荐)</code><br>或<br>/usr/nginx/sbin/nginx -t</p></li></ol><hr><h1 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h1><p>如果服务器正在运行的Nginx要进行升级、添加或删除模块时，我们需 要停掉服务器并做相应修改，这样服务器就要在一段时间内停止服务，Nginx可以在不停机的情况下进行各种升级动作而不影响服务器运行。<br>步骤1：<br>如果升级Nginx程序，先用新程序替换旧程序文件，编译安装的话新程序直接编译到Nginx安装目录中。<br>步骤2：执行命令<br>kill -USR2 旧版程序的主进程号或进程文件名<br>此时旧的Nginx主进程将会把自己的进程文件改名为.oldbin，然后执行新版 Nginx。新旧Nginx会同市运行，共同处理请求。<br>这时要逐步停止旧版 Nginx，输入命令：<br>kill -WINCH 旧版主进程号<br>慢慢旧的工作进程就都会随着任务执行完毕而退出，新版的Nginx的工作进程会逐渐取代旧版 工作进程。<br>此时，我们可以决定使用新版还是恢复到旧版。<br>不重载配置启动新/旧工作进程<br>kill -HUP 旧/新版主进程号<br>从容关闭旧/新进程<br>kill -QUIT 旧/新主进程号<br>如果此时报错，提示还有进程没有结束就用下面命令先关闭旧/新工作进程，再关闭主进程号：<br>kill -TERM 旧/新工作进程号<br>这样下来，如果要恢复到旧版本，只需要上面的几个步 骤都是操作新版主进程号，如果要用新版本就上面的几个步骤都操作旧版主进程号就行了。<br>上面就是Nginx的一些基本的操作，希望以后Nginx能有更好的方法来处理这些操作， 最好是Nginx的命令而不是向Nginx进程发送系统信号。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nginx日常维护常用命令&quot;&gt;&lt;a href=&quot;#Nginx日常维护常用命令&quot; class=&quot;headerlink&quot; title=&quot;Nginx日常维护常用命令&quot;&gt;&lt;/a&gt;&lt;font color=&quot;#0099ff&quot; size=&quot;12&quot; face=&quot;黑体&quot;&gt;Nginx
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx系列(2)安装</title>
    <link href="http://oleaster.cn/2018/03/13/Nginx%E7%B3%BB%E5%88%972/"/>
    <id>http://oleaster.cn/2018/03/13/Nginx系列2/</id>
    <published>2018-03-13T02:46:12.000Z</published>
    <updated>2018-04-09T07:44:24.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><h2 id="1-windows安装"><a href="#1-windows安装" class="headerlink" title="1. windows安装"></a>1. windows安装</h2><p>官方网站下载地址：<br><a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a></p><p>如下图所示，下载对应的版本的nginx压缩包，解压到自己电脑上存放软件的文件夹中即可<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/6.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><br>解压完成后，文件目录结构如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/7.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure></p><p><strong> 启动nginx </strong></p><p>1） 直接双击该目录下的nginx.exe，即可启动nginx服务器</p><p>2） 命令行计入该文件夹，执行nginx命令，也会直接启动nginx服务器</p><blockquote><p>D:/resp_application/nginx-1.13.5&gt; nginx</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/8.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p><strong> 访问nginx </strong></p><p>打开浏览器，输入地址：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a>  ，访问页面，出现如下页面表示访问成功<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/9.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure></p><p><strong> 停止nginx </strong></p><p>命令行进入nginx根目录，执行如下命令，停止服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 强制停止nginx服务器，如果有未处理的数据，丢弃</span><br><span class="line">D:/resp_application/nginx-1.13.5&gt; nginx -s stop</span><br><span class="line"></span><br><span class="line"># 优雅的停止nginx服务器，如果有未处理的数据，等待处理完成之后停止</span><br><span class="line">D:/resp_application/nginx-1.13.5&gt; nginx -s quit</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/10.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><hr><h2 id="2-ubuntu安装"><a href="#2-ubuntu安装" class="headerlink" title="2. ubuntu安装"></a>2. ubuntu安装</h2><p>按照正常软件的安装方式，直接通过如下命令进行安装：</p><blockquote><p>$ sudo apt-get install nginx</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/11.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>安装完成即可，在/usr/sbin/目录下是nginx命令所在目录，在/etc/nginx/目录下是nginx所有的配置文件，用于配置nginx服务器以及负载均衡等信息</p><p><strong>查看nginx进程是否启动</strong></p><blockquote><p>$ ps -ef|grep nginx</p></blockquote><p>nginx会自动根据当前主机的CPU的内核数目创建对应的进程数量(当前ubuntu主机是2核4线程配置)<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/12.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure></p><p><code>备注</code>这里启动的服务进程其实是4个进程，因为nginx进程在启动的时候，会附带一个守护进程，用于保护正式进程不被异常终止；<br>如果守护进程一旦返现nginx继承被终止了，会自动重启该进程。守护进程一般会称为master进程，业务进程被称为worker进程</p><p><strong> 启动nginx服务器命令</strong><br>直接执行nginx会按照默认的配置文件进行服务器的启动</p><blockquote><p>$ nginx</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/13.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p><strong> 停止nginx服务命令</strong></p><p>和windows系统执行过程一样，两种停止方式</p><blockquote><p>$ nginx -s stop<br>or<br>$ nginx -s quit</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/14.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p>重新启动加载</p><p>同样也可以使用命令reopen和reload来重新启动nginx或者重新加载配合着文件。</p><hr><h2 id="3-mac-os安装"><a href="#3-mac-os安装" class="headerlink" title="3. mac os安装"></a>3. mac os安装</h2><p>直接通过brew进行nginx的安装，或者下载tar.gz压缩包都是可以的。</p><p>直接通过brew进行安装</p><blockquote><p>brew install nginx</p></blockquote><p>安装完成后，后续的命令操作，服务器的启动、进程查看、服务器的停止、服务器的重启已经文件加载命令都是一致的。</p><hr><h2 id="4-CentOS-7下安装部署"><a href="#4-CentOS-7下安装部署" class="headerlink" title="4.CentOS 7下安装部署"></a>4.CentOS 7下安装部署</h2><p>配置epel yum 源</p><blockquote><p>wget <a href="http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm" target="_blank" rel="noopener">http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a><br>rpm -ivh epel-release-latest-7.noarch.rpm<br>yum install nginx -y</p></blockquote><p>查看确认 是否安装</p><blockquote><p>[root@localhost ~]# rpm -qa | grep nginx</p></blockquote><p>查看 安装nginx 所生成的文件 </p><blockquote><p>[root@localhost ~]# rpm -ql nginx </p></blockquote><p>启动nginx  </p><blockquote><p>systemctl start nginx</p></blockquote><p>设置开机启动 </p><blockquote><p>systemctl enable nginx</p></blockquote><p>查看nginx 启动状态</p><blockquote><p>systemctl status nginx</p></blockquote><p>停止开机自启动</p><blockquote><p>systemctl disable nginx</p></blockquote><p>重新启动服务</p><blockquote><p>systemctl restart nginx</p></blockquote><p>查看所有已启动的服务</p><blockquote><p>systemctl list-units –type=service</p></blockquote><p><code>备注</code>centos 7以上是用Systemd进行系统初始化的，Systemd服务文件以.service结尾，yum命令会自动创建nginx.service文件,如果手动安装须手动创建<br>上面所有缩写也可写成 systemctl status nginx.service, nginx.service 默认位置 /lib/systemd/system/nginx.service.<br>内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=nginx </span><br><span class="line">After=network.target </span><br><span class="line"> </span><br><span class="line">[Service] </span><br><span class="line">Type=forking </span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx </span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload </span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true </span><br><span class="line"> </span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>Description:描述服务<br>After:描述服务类别<br>[Service]服务运行参数的设置<br>Type=forking是后台运行的形式<br>ExecStart为服务的具体运行命令<br>ExecReload为重启命令<br>ExecStop为停止命令<br>PrivateTmp=True表示给服务分配独立的临时空间<br>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径<br>[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</p></blockquote><p>查看是否监听</p><blockquote><p>ss -tnl | grep 80 </p></blockquote><p><code>备注</code>如果不能正常访问，关闭防火墙</p><blockquote><p>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动<br>firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</p></blockquote><hr><h2 id="5-Nginx手动安装"><a href="#5-Nginx手动安装" class="headerlink" title="5.Nginx手动安装"></a>5.Nginx手动安装</h2><p>nginx可以使用各平台的默认包来安装，下面介绍使用源码编译安装，包括具体的编译参数信息。</p><p>正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。</p><ul><li>ububtu平台编译环境可以使用以下指令</li></ul><blockquote><p>apt-get install build-essential<br>apt-get install libtool</p></blockquote><ul><li><p>centos平台编译环境使用如下指令</p><ol><li><p>安装make：</p><blockquote><p>yum -y install gcc automake autoconf libtool make</p></blockquote></li><li><p>安装g++:</p><blockquote><p>yum install gcc gcc-c++</p></blockquote></li></ol></li></ul><hr><font color="#0099ff" size="12" face="黑体">下面正式开始</font><ol><li>pcre：用于支持rewrite模块</li><li>zlib：用于支持gzip模块</li><li>openssl：用于支持ssl功能</li></ol><h3 id="1-选定源码目录"><a href="#1-选定源码目录" class="headerlink" title="1.选定源码目录"></a>1.选定源码目录</h3><p>可以是任何目录，本文选定的是/usr/local/src</p><blockquote><p>cd /usr/local/src</p></blockquote><h3 id="2-安装PCRE库"><a href="#2-安装PCRE库" class="headerlink" title="2.安装PCRE库"></a>2.安装PCRE库</h3><p><a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a> 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz</span><br><span class="line">tar zxvf pcre-8.41.tar.gz</span><br><span class="line">cd pcre-8.41</span><br><span class="line">./configure --prefix=/opt/local/pcre-8.41 ;</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h3 id="3-安装zlib库"><a href="#3-安装zlib库" class="headerlink" title="3.安装zlib库"></a>3.安装zlib库</h3><p><a href="http://zlib.net/zlib-1.2.11.tar.gz" target="_blank" rel="noopener">http://zlib.net/zlib-1.2.11.tar.gz</a> 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line">cd zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="4-安装ssl"><a href="#4-安装ssl" class="headerlink" title="4.安装ssl"></a>4.安装ssl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://www.openssl.org/source/openssl-1.0.2n.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.2n.tar.gz</span><br><span class="line">cd openssl-1.0.2n</span><br><span class="line">./config</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="5-安装Nginx"><a href="#5-安装Nginx" class="headerlink" title="5.安装Nginx"></a>5.安装Nginx</h3><p>Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://nginx.org/download/nginx-1.12.2.tar.gz</span><br><span class="line">tar -zxvf nginx-1.12.2.tar.gz </span><br><span class="line">mv nginx-1.12.2 nginx</span><br><span class="line">cd nginx/</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">--prefix=/usr/local/nginx \</span><br><span class="line">--sbin-path=/usr/sbin/nginx \</span><br><span class="line">--conf-path=/etc/nginx/nginx.conf \</span><br><span class="line">--pid-path=/run/nginx.pid \</span><br><span class="line">--http-client-body-temp-path=/var/lib/nginx/body \</span><br><span class="line">--http-fastcgi-temp-path=/var/lib/nginx/fastcgi \</span><br><span class="line">--http-proxy-temp-path=/var/lib/nginx/proxy \</span><br><span class="line">--http-scgi-temp-path=/var/lib/nginx/scgi \</span><br><span class="line">--http-uwsgi-temp-path=/var/lib/nginx/uwsgi \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_realip_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-pcre=/usr/local/src/pcre-8.41 \</span><br><span class="line">--with-zlib=/usr/local/src/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/local/src/openssl-1.0.2n</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>--with-pcre=/usr/local/src/pcre-8.41 指的是pcre-8.41 的源码路径。<br>--with-zlib=/usr/local/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。<br>--with-openssl=/usr/local/src/openssl-1.0.2n 指的是openssl-1.0.2n 的源码路径。<br>pcre、openssl的安装路径在/opt/local，但这里只需要源码路径</p><p>赋予普通用户操作权限</p><blockquote><p>sudo chmod u+s /usr/local/nginx/nginx</p></blockquote><p>安装成功后 /usr/local/nginx 目录下如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fastcgi.conf            koi-win             nginx.conf.default</span><br><span class="line">fastcgi.conf.default    logs                scgi_params</span><br><span class="line">fastcgi_params          mime.types          scgi_params.default</span><br><span class="line">fastcgi_params.default  mime.types.default  uwsgi_params</span><br><span class="line">html                    nginx               uwsgi_params.default</span><br><span class="line">koi-utf                 nginx.conf          win-utf</span><br></pre></td></tr></table></figure><h3 id="6-启动"><a href="#6-启动" class="headerlink" title="6.启动"></a>6.启动</h3><p>确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx，</p><blockquote><p>netstat -ano|grep 80</p></blockquote><p>如果查不到结果后执行，以下步骤（ubuntu下必须用sudo启动，不然只能在前台运行）</p><blockquote><p>sudo /usr/local/nginx/nginx</p></blockquote><p>打开浏览器访问此机器的 IP，如果浏览器出现 <strong> Welcome to nginx! </strong> 则表示 Nginx 已经安装并运行成功。<br>到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了</p><hr><h1 id="安装排错"><a href="#安装排错" class="headerlink" title=" 安装排错 "></a><strong> 安装排错 </strong></h1><p><strong> 附 </strong>:可能遇到的错误和一些帮助信息</p><h2 id="编译pcre错误"><a href="#编译pcre错误" class="headerlink" title="编译pcre错误"></a>编译pcre错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libtool: compile: unrecognized option `-DHAVE_CONFIG_H&apos;</span><br><span class="line">libtool: compile: Try `libtool --help&apos; for more information.</span><br><span class="line">make[1]: *** [pcrecpp.lo] Error 1</span><br><span class="line">make[1]: Leaving directory `/usr/local/src/pcre-8.34&apos;</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p>解决办法：安装g++,别忘了重新configure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install g++</span><br><span class="line">apt-get install build-essential</span><br><span class="line">make clean</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><h2 id="make出错"><a href="#make出错" class="headerlink" title="make出错"></a>make出错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make: *** No rule to make target `build&apos;, needed by `default&apos;.  Stop.</span><br><span class="line">./configure: error: SSL modules require the OpenSSL library.</span><br><span class="line">You can either do not enable the modules, or install the OpenSSL library</span><br><span class="line">into the system, or build the OpenSSL library statically from the source</span><br><span class="line">with nginx by using --with-openssl=&lt;path&gt; option.</span><br></pre></td></tr></table></figure><p>按照第4步的安装方法或</p><ul><li>ubuntu下<blockquote><p>apt-get install openssl<br>apt-get install libssl-dev</p></blockquote></li><li>centos下<blockquote><p>yum -y install openssl openssl-devel</p></blockquote></li></ul><h2 id="启用的模块"><a href="#启用的模块" class="headerlink" title="启用的模块"></a>启用的模块</h2><p>切换到解压后的nginx目录中执行：</p><blockquote><p>./configure –prefix=/opt/demo/nginx –add-module=/home/fastdfs-nginx-module/src  –with-http_stub_status_module –with-http_ssl_module</p></blockquote><p>可能出现的错误：<br>出现：./configure:  error: the HTTP rewrite module requires the PCRE library.</p><pre><code>解决方法：yum -y install pcre-devel</code></pre><p>出现：SSL modules require the OpenSSL library</p><pre><code>解决方法：yum install openssl-devel </code></pre><p><code>特别注意：</code><br>在已安装的nginx上进行添加模块的话执行到这里就行了，把objs中的nginx替换掉之前的安装的nginx/sbin/中的nginx文件，然后重启nginx就行了，如果执行下一步的install，会导致之前安装的nginx被覆盖，比如之前配置好的nginx.conf文件</p><h2 id="nginx编译选项"><a href="#nginx编译选项" class="headerlink" title="nginx编译选项"></a>nginx编译选项</h2><p>make是用来编译的，它从Makefile中读取指令，然后编译。</p><p>make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>configure命令是用来检测你的安装平台的目标特征的。它定义了系统的各个方面，包括nginx的被允许使用的连接处理的方法，比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本，执行结束时，它会创建一个Makefile文件。nginx的configure命令支持以下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--prefix=path    定义一个目录，存放服务器上的文件 ，也就是nginx的安装目录。默认使用 /usr/local/nginx。</span><br><span class="line">--sbin-path=path 设置nginx的可执行文件的路径，默认为  prefix/sbin/nginx.</span><br><span class="line">--conf-path=path  设置在nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为prefix/conf/nginx.conf.</span><br><span class="line">--pid-path=path  设置nginx.pid文件，将存储的主进程的进程号。安装完成后，可以随时改变的文件名 ， 在nginx.conf配置文件中使用 PID指令。默认情况下，文件名 为prefix/logs/nginx.pid.</span><br><span class="line">--error-log-path=path 设置主错误，警告，和诊断文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的error_log指令。默认情况下，文件名 为prefix/logs/error.log.</span><br><span class="line">--http-log-path=path  设置主请求的HTTP服务器的日志文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的access_log指令。默认情况下，文件名 为prefix/logs/access.log.</span><br><span class="line">--user=name  设置nginx工作进程的用户。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的用户名是nobody。</span><br><span class="line">--group=name  设置nginx工作进程的用户组。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的为非特权用户。</span><br><span class="line">--with-select_module --without-select_module 启用或禁用构建一个模块来允许服务器使用select()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。</span><br><span class="line">--with-poll_module --without-poll_module 启用或禁用构建一个模块来允许服务器使用poll()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。</span><br><span class="line">--without-http_gzip_module — 不编译压缩的HTTP服务器的响应模块。编译并运行此模块需要zlib库。</span><br><span class="line">--without-http_rewrite_module  不编译重写模块。编译并运行此模块需要PCRE库支持。</span><br><span class="line">--without-http_proxy_module — 不编译http_proxy模块。</span><br><span class="line">--with-http_ssl_module — 使用https协议模块。默认情况下，该模块没有被构建。建立并运行此模块的OpenSSL库是必需的。</span><br><span class="line">--with-pcre=path — 设置PCRE库的源码路径。PCRE库的源码（版本4.4 - 8.30）需要从PCRE网站下载并解压。其余的工作是Nginx的./ configure和make来完成。正则表达式使用在location指令和 ngx_http_rewrite_module 模块中。</span><br><span class="line">--with-pcre-jit —编译PCRE包含“just-in-time compilation”（1.1.12中， pcre_jit指令）。</span><br><span class="line">--with-zlib=path —设置的zlib库的源码路径。要下载从 zlib（版本1.1.3 - 1.2.5）的并解压。其余的工作是Nginx的./ configure和make完成。ngx_http_gzip_module模块需要使用zlib 。</span><br><span class="line">--with-cc-opt=parameters — 设置额外的参数将被添加到CFLAGS变量。例如,当你在FreeBSD上使用PCRE库时需要使用:--with-cc-opt=&quot;-I /usr/local/include。.如需要需要增加 select()支持的文件数量:--with-cc-opt=&quot;-D FD_SETSIZE=2048&quot;.</span><br><span class="line">--with-ld-opt=parameters —设置附加的参数，将用于在链接期间。例如，当在FreeBSD下使用该系统的PCRE库,应指定:--with-ld-opt=&quot;-L /usr/local/lib&quot;.</span><br></pre></td></tr></table></figure></p><p>典型实例(下面为了展示需要写在多行，执行时内容需要在同一行)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">    --sbin-path=/usr/local/nginx/nginx</span><br><span class="line">    --conf-path=/usr/local/nginx/nginx.conf</span><br><span class="line">    --pid-path=/usr/local/nginx/nginx.pid</span><br><span class="line">    --with-http_ssl_module</span><br><span class="line">    --with-pcre=../pcre-4.4</span><br><span class="line">    --with-zlib=../zlib-1.1.3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><h2 id="nginx添加模块"><a href="#nginx添加模块" class="headerlink" title="nginx添加模块"></a>nginx添加模块</h2><p>有时候我们已经编译好了nginx，但是后期需要添加一个未被编译的模块。</p><ul><li>以–with-http_realip_module为例演示说明。</li></ul><ol><li>查看当前nginx编译安装时安装了哪些模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module </span><br><span class="line">--with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module 等等</span><br></pre></td></tr></table></figure><ol><li>加入–with-http_sub_module模块，重新编译（<code>注意</code> 最后不需要执行make install）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx</span><br><span class="line">./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module </span><br><span class="line">--with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-http_realip_module</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ol><p>在 [+<strong>原有参数</strong>+]–with-http_realip_module</p><ul><li>以第三方的替换模块:–ngx_http_substitutions_filter_module为例演示说明。<br>  经过测试，这个模块至少有如下实用功能：<br>  ①、支持多次替换<br>  ②、支持正则替换<br>  ③、支持中文替换<br>Ps：略有遗憾的是，这个替换不能使用到 if 判断模块内，否则就超神了。。。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /root/ </span><br><span class="line">wget -O ngx_http_substitutions_filter_module-master.zip https://github.com/yaoweibin/ngx_http_substitutions_filter_module/archive/master.zip</span><br><span class="line">unzip ngx_http_substitutions_filter_module-master.zip</span><br><span class="line">cd ngx_http_substitutions_filter_module-master &amp;&amp; pwd </span><br><span class="line">#/root/ngx_http_substitutions_filter_module-master</span><br></pre></td></tr></table></figure><ol><li>查看当前nginx编译安装模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module </span><br><span class="line">--with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-http_realip_module 等等</span><br></pre></td></tr></table></figure><ol><li>加入–with-http_sub_module模块，重新编译（<code>注意</code> 最后不需要执行make install）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx</span><br><span class="line">./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module </span><br><span class="line">--with-http_v2_module --with-http_gzip_static_module --with-http_sub_module --with-http_realip_module </span><br><span class="line">--add-module=/root/ngx_http_substitutions_filter_module-master/</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ol><p>./configure [+<strong>原有参数</strong>+] –add-module=/root/ngx_http_substitutions_filter_module-master/</p><p><strong> 添加未被编译的模块和第三方模块 区别在 ./configure追加的信息 </strong></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx安装&quot;&gt;&lt;a href=&quot;#Nginx安装&quot; class=&quot;headerlink&quot; title=&quot;Nginx安装&quot;&gt;&lt;/a&gt;Nginx安装&lt;/h1&gt;&lt;h2 id=&quot;1-windows安装&quot;&gt;&lt;a href=&quot;#1-windows安装&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx系列(1)概述</title>
    <link href="http://oleaster.cn/2018/03/12/Nginx%E7%B3%BB%E5%88%971/"/>
    <id>http://oleaster.cn/2018/03/12/Nginx系列1/</id>
    <published>2018-03-12T02:46:12.000Z</published>
    <updated>2018-03-28T07:29:52.869Z</updated>
    
    <content type="html"><![CDATA[<font color="#0099ff" size="12" face="黑体">Nginx概述及简介</font><hr><h1 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h1><p>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；<br>Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。<br><strong> 中文文档:</strong> <a href="http://www.nginx.cn/doc/" target="_blank" rel="noopener">http://www.nginx.cn/doc/</a><br><strong> Tengine译:</strong> <a href="http://tengine.taobao.org/nginx_docs/cn/" target="_blank" rel="noopener">http://tengine.taobao.org/nginx_docs/cn/</a><br><strong> 官方网站:</strong> <a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a><br>这里主要通过三个方面简单介绍Nginx</p><ul><li>反向代理</li><li>负载均衡</li><li>Nginx特点</li></ul><h2 id="1-反向代理"><a href="#1-反向代理" class="headerlink" title="1. 反向代理"></a>1. 反向代理</h2><p>关于代理</p><p>说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；</p><p>此时就设计到两个角色，一个是被代理角色，一个是目标角色，被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；<br>如同生活中的专卖店~客人到adidas专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是adidas厂家，目标角色就是用户<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/1.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure></p><p>正向代理</p><p>说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触的到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理</p><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/2.png" alt="图1.1" title="">                </div>                <div class="image-caption">图1.1</div>            </figure></p><p>反向代理</p><p>明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，<br>有兴趣的童鞋可以访问Tengine的官网查看具体的信息：<a href="http://tengine.taobao.org/" target="_blank" rel="noopener">http://tengine.taobao.org/</a><br>那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/3.png" alt="图1.2" title="">                </div>                <div class="image-caption">图1.2</div>            </figure></p><p>通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色</p><p>反向代理，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p><p>项目场景</p><p>通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/4.png" alt="图1.3" title="">                </div>                <div class="image-caption">图1.3</div>            </figure></p><h2 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. 负载均衡</h2><p>我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p><p>这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量</p><p>请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则</p><p>所以~将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p><p>负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/nginx/5.png" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><p><strong> Nginx支持的负载均衡调度算法方式如下：</strong></p><ul><li><p>weight轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</p></li><li><p>ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p></li><li><p>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块</p></li><li><p>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包</p></li></ul><h2 id="3-Nginx特点"><a href="#3-Nginx特点" class="headerlink" title="3. Nginx特点"></a>3. Nginx特点</h2><p>1、热部署</p><p>我个人觉得这个很不错。在master管理进程与worker工作进程的分离设计，使的Nginx具有热部署的功能，那么在7×24小时不间断服务的前提下，升级Nginx的可执行文件。也可以在不停止服务的情况下修改配置文件，更换日志文件等功能。</p><p>2、可以高并发连接</p><p>这是一个很重要的一个特性！在这一个互联网快速发展，互联网用户数量不断增加，一些大公司、网站都需要面对高并发请求，如果有一个能够在峰值顶住10万以上并发请求的Server，肯定会得到大家的青睐。理论上，Nginx支持的并发连接上限取决于你的内存，10万远未封顶。</p><p>3、低的内存消耗</p><p>在一般的情况下，10000个非活跃的HTTP Keep-Alive 连接在Nginx中仅消耗2.5M的内存，这也是Nginx支持高并发连接的基础。</p><p>4、处理响应请求很快</p><p>在正常的情况下，单次请求会得到更快的响应。在高峰期，Nginx可以比其他的Web服务器更快的响应请求。</p><p>5、具有很高的可靠性</p><p>Nginx是一个高可靠性的Web服务器，这也是我们为什么选择Nginx的基本条件，现在很多的网站都在使用Nginx，足以说明Nginx的可靠性。高可靠性来自其核心框架代码的优秀设计、模块设计的简单性；并且这些模块都非常的稳定。</p><p>目前总结以上5点的特性，有说的不对的请大家及时反馈，谢谢。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;#0099ff&quot; size=&quot;12&quot; face=&quot;黑体&quot;&gt;Nginx概述及简介&lt;/font&gt;

&lt;hr&gt;
&lt;h1 id=&quot;Nginx概述&quot;&gt;&lt;a href=&quot;#Nginx概述&quot; class=&quot;headerlink&quot; title=&quot;Nginx概述&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://oleaster.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>VirtualBox内Linux系统怎样与Windows共享文件夹</title>
    <link href="http://oleaster.cn/2018/02/09/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8EWindows%E5%85%B1%E4%BA%AB/"/>
    <id>http://oleaster.cn/2018/02/09/Linux系统与Windows共享/</id>
    <published>2018-02-09T02:46:12.000Z</published>
    <updated>2018-03-21T09:30:07.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-在本机系统设置一个共享文件夹，用于与Ubuntu交互的区域空间"><a href="#1-在本机系统设置一个共享文件夹，用于与Ubuntu交互的区域空间" class="headerlink" title="1.在本机系统设置一个共享文件夹，用于与Ubuntu交互的区域空间"></a>1.在本机系统设置一个共享文件夹，用于与Ubuntu交互的区域空间</h1><div style="align:left"><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/1.png"><br></div><hr><h1 id="2-右击状态栏上共享文件夹图标或菜单栏“设备-共享文件夹”，打开共享文件夹设置，如图示"><a href="#2-右击状态栏上共享文件夹图标或菜单栏“设备-共享文件夹”，打开共享文件夹设置，如图示" class="headerlink" title="2.右击状态栏上共享文件夹图标或菜单栏“设备-共享文件夹”，打开共享文件夹设置，如图示"></a>2.右击状态栏上共享文件夹图标或菜单栏“设备-共享文件夹”，打开共享文件夹设置，如图示</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/2.png" alt="图示1" title="">                </div>                <div class="image-caption">图示1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/3.png" alt="图示2" title="">                </div>                <div class="image-caption">图示2</div>            </figure><hr><h1 id="3-点击共享文件夹设置框，右上角的添加按钮"><a href="#3-点击共享文件夹设置框，右上角的添加按钮" class="headerlink" title="3.点击共享文件夹设置框，右上角的添加按钮"></a>3.点击共享文件夹设置框，右上角的添加按钮</h1><div style="align:left"><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/4.png"><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/5.png"><br><br><code>选择之前本机设置的共享文件夹</code><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/6.png"><br><br><code>此时一定不可以勾选自动挂载</code><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/7.png"><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/8.png"><br></div><hr><h1 id="4-设置好共享名后，进入Linux系统，打开终端，先执行命令，在挂载点目录添加“Windows-Share”目录，接着执行”-mount-t-vboxsf-VirtureBox-Share-mnt-Windows-Share-“-就能完成共享文件夹的设置。"><a href="#4-设置好共享名后，进入Linux系统，打开终端，先执行命令，在挂载点目录添加“Windows-Share”目录，接着执行”-mount-t-vboxsf-VirtureBox-Share-mnt-Windows-Share-“-就能完成共享文件夹的设置。" class="headerlink" title="4.设置好共享名后，进入Linux系统，打开终端，先执行命令，在挂载点目录添加“Windows_Share”目录，接着执行” mount -t vboxsf VirtureBox_Share /mnt/Windows_Share/“,就能完成共享文件夹的设置。"></a>4.设置好共享名后，进入Linux系统，打开终端，先执行命令，在挂载点目录添加“Windows_Share”目录，接着执行” mount -t vboxsf VirtureBox_Share /mnt/Windows_Share/“,就能完成共享文件夹的设置。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[oracle@ODIGettingStarted ~]$ su</span><br><span class="line">Password: </span><br><span class="line">[root@ODIGettingStarted oracle]# mkdir /mnt/Windows_Share</span><br><span class="line">[root@ODIGettingStarted oracle]# mount -t vboxsf VirtureBox_Share /mnt/Windows_Share/</span><br><span class="line">[root@ODIGettingStarted oracle]#</span><br></pre></td></tr></table></figure><hr><h1 id="5-设置完成，可以创建几个文件，测试一下"><a href="#5-设置完成，可以创建几个文件，测试一下" class="headerlink" title="5.设置完成，可以创建几个文件，测试一下"></a>5.设置完成，可以创建几个文件，测试一下</h1><blockquote><p>测试方法：<br>1.在本地C:\Software\Oracle\VirtureBox_Share创建一个文件，到mnt/ Windows_Share/目录 查看。<br>2.在mnt/Windows_Share/目录创建一个文件，在本机C:\Software\Oracle\VirtureBox_Share进行查看</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ODIGettingStarted oracle]# cd /mnt/Windows_Share/</span><br><span class="line">[root@ODIGettingStarted Windows_Share]# ls</span><br><span class="line">window创建.txt</span><br><span class="line">[root@ODIGettingStarted Windows_Share]# touch linux.txt</span><br><span class="line">[root@ODIGettingStarted Windows_Share]# ls</span><br><span class="line">linux.txt window创建.txt</span><br><span class="line">[root@ODIGettingStarted Windows_Share]#</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/9.png"><br><img src="https://raw.githubusercontent.com/Jerryping/BolgImage/master/1/10.png"></p><hr><h1 id="6-设置自动挂载"><a href="#6-设置自动挂载" class="headerlink" title="6.设置自动挂载"></a>6.设置自动挂载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[oracle@ODIGettingStarted ~]$ su</span><br><span class="line"></span><br><span class="line">Password: </span><br><span class="line"></span><br><span class="line">[root@ODIGettingStarted oracle]#vim /etc/fstab</span><br></pre></td></tr></table></figure><blockquote><p> 添加 VirtureBox_Share /mnt/Windows_Share/ vboxsf rw,gid=110,uid=1100,auto 0 0</p></blockquote><hr><h1 id="7-卸载挂载点命令："><a href="#7-卸载挂载点命令：" class="headerlink" title="7. 卸载挂载点命令："></a>7. 卸载挂载点命令：</h1><blockquote><p>umount -f /mnt/share</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-在本机系统设置一个共享文件夹，用于与Ubuntu交互的区域空间&quot;&gt;&lt;a href=&quot;#1-在本机系统设置一个共享文件夹，用于与Ubuntu交互的区域空间&quot; class=&quot;headerlink&quot; title=&quot;1.在本机系统设置一个共享文件夹，用于与Ubuntu
      
    
    </summary>
    
      <category term="OS" scheme="http://oleaster.cn/categories/OS/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux各目录及每个目录的详细介绍</title>
    <link href="http://oleaster.cn/2018/02/08/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://oleaster.cn/2018/02/08/Linux目录结构/</id>
    <published>2018-02-08T02:46:12.000Z</published>
    <updated>2018-03-21T09:30:05.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>【常见目录说明】</p><blockquote><table><thead><tr><th style="text-align:left"><strong><code>目录</code></strong></th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>/</code></strong></td><td style="text-align:left">根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中</td></tr><tr><td style="text-align:left"><strong><code>/bin</code></strong></td><td style="text-align:left">存放二进制可执行文件(<font color="#00ffff" size="3">ls,cat,mkdir</font>等)，常用命令一般都在这里。</td></tr><tr><td style="text-align:left"><strong><code>/etc</code></strong></td><td style="text-align:left">存放系统管理和配置文件</td></tr><tr><td style="text-align:left"><strong><code>/home</code></strong></td><td style="text-align:left">存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示</td></tr><tr><td style="text-align:left"><strong><code>/usr</code></strong></td><td style="text-align:left">用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。</td></tr><tr><td style="text-align:left"><strong><code>/opt</code></strong></td><td style="text-align:left">额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。</td></tr><tr><td style="text-align:left"><strong><code>/proc</code></strong></td><td style="text-align:left">虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</td></tr><tr><td style="text-align:left"><strong><code>/root</code></strong></td><td style="text-align:left">超级用户（系统管理员）的主目录（特权阶级^o^）</td></tr><tr><td style="text-align:left"><strong><code>/sbin</code></strong></td><td style="text-align:left">存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。</td></tr><tr><td style="text-align:left"><strong><code>/dev</code></strong></td><td style="text-align:left">用于存放设备文件。</td></tr><tr><td style="text-align:left"><strong><code>/mnt</code></strong></td><td style="text-align:left">系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。</td></tr><tr><td style="text-align:left"><strong><code>/boot</code></strong></td><td style="text-align:left">存放用于系统引导时使用的各种文件</td></tr><tr><td style="text-align:left"><strong><code>/lib</code></strong></td><td style="text-align:left">存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。</td></tr><tr><td style="text-align:left"><strong><code>/tmp</code></strong></td><td style="text-align:left">用于存放各种临时文件，是公用的临时文件存储点。</td></tr><tr><td style="text-align:left"><strong><code>/var</code></strong></td><td style="text-align:left">用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。</td></tr><tr><td style="text-align:left"><strong><code>/lost+found</code></strong></td><td style="text-align:left">这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里</td></tr></tbody></table></blockquote><p>/usr 最庞大的目录，其中包含：<br>/usr/x11r6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库</p><hr><h1 id="下面请看详细内容"><a href="#下面请看详细内容" class="headerlink" title="下面请看详细内容"></a>下面请看详细内容</h1><h2 id="dev："><a href="#dev：" class="headerlink" title="/dev："></a>/dev：</h2><pre><code>dev是设备(device)的英文缩写。/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和wndows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。Linux沿袭Unix的风格，将所有设备认成是一个文件。设备文件用特定的约定命名.设备文件在安装时由系统产生，以后可以用/dev/makedev 描述。/ d e v / m a k e d e v.local是统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准mkedev 的一部分)。</code></pre><blockquote><p>设备文件分为两种：块设备文件(b)和字符设备文件(c)<br>设备文件一般存放在/dev目录下，对常见设备文件作如下说明：</p></blockquote><ol><li>/dev/hd[a-t]：IDE设备</li><li>/dev/sd[a-z]：SCSI设备</li><li>/dev/fd[0-7]：标准软驱</li><li>/dev/md[0-31]：软raid设备</li><li>/dev/loop[0-7]：本地回环设备</li><li>/dev/ram[0-15]：内存</li><li>/dev/null：无限数据接收设备,相当于黑洞</li><li>/dev/zero：无限零资源</li><li>/dev/tty[0-63]：虚拟终端</li><li>/dev/ttyS[0-3]：串口(对于dos来说就是“COM1”口。)</li><li>/dev/lp[0-3]：并口</li><li>/dev/console：控制台</li><li>/dev/fb[0-31]：framebuffer</li><li>/dev/cdrom =&gt; /dev/hdc</li><li>/dev/modem =&gt; /dev/ttyS[0-9]</li><li>/dev/pilot =&gt; /dev/ttyS[0-9]</li><li>/dev/random：随机数设备</li><li>/dev/urandom：随机数设备 (PS：随机数设备，后面我会再写篇博客总结一下)</li><li>/dev目录下的节点是怎么创建的?</li><li>devf或者udev会自动帮你创建得。</li><li>kobject是sysfs文件系统的基础，udev通过监测、检测sysfs来获取新创建的设备的。</li></ol><hr><h2 id="etc："><a href="#etc：" class="headerlink" title="/etc："></a>/etc：</h2><pre><code>包含很多文件.许多网络配置文件也在/etc 中. 下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的man页。许多网络配置文件也在/etc 中。</code></pre><ol><li>/etc/rc   or /etc/rc.d   or /etc/rc*.d<br>　　启动、或改变运行级时运行的scripts或scripts的目录.</li><li>/etc/passwd<br>　　用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息.</li><li>/etc/fdprm<br>　　软盘参数表，用以说明不同的软盘格式。可用setfdprm进行设置。更多的信息见setfdprm的帮助页。</li><li>/etc/fstab<br>　　启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表. Linux下，也包括用swapon -a启用的swap区的信息.</li><li>/etc/group<br>　　类似/etc/passwd ，但说明的不是用户而是组. </li><li>/etc/inittab<br>　　init 的配置文件. </li><li>/etc/issue<br>　　getty 在登录提示符前的输出信息.通常包括系统的一段短说明或欢迎信息.内容由系统管理员确定.</li><li>/etc/magic<br>　　file的配置文件。包含不同文件格式的说明，file基于它猜测文件类型。</li><li>/etc/motd<br>　　Message Of The Day，成功登录后自动输出.内容由系统管理员确定.经常用于通告信息，如计划关机时间的警告. </li><li>/etc/mtab<br>　　当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新.需要一个当前安装的文件系统的列表时使用，例如df 命令. </li><li>/etc/shadow<br>　　在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读.这使破译口令更困难. </li><li>/etc/login.defs<br>　　login 命令的配置文件. </li><li>/etc/printcap<br>　　类似/etc/termcap ，但针对打印机.语法不同. </li><li>/etc/profile , /etc/csh.login , /etc/csh.cshrc<br>　　登录或启动时Bourne或C shells执行的文件.这允许系统管理员为所有用户建立全局缺省环境. </li><li>/etc/securetty<br>　　确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权. </li><li>/etc/shells<br>　　列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录. </li><li>/etc/sysconfig<br>　　网络配置相关目录</li></ol><hr><h2 id="proc："><a href="#proc：" class="headerlink" title="/proc："></a>/proc：</h2><pre><code>文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系统的信息。下面说明一些最重要的文件和目录(/proc 文件系统在proc man页中有更详细的说明)。</code></pre><ol><li>/proc/x<br>　　关于进程x的信息目录，这一x是这一进程的标识号。每个进程在/proc 下有一个名为自己进程号的目录。</li><li>/proc/cmdline<br>　　加载 kernel 时所下达的相关参数！查阅此文件，可了解系统是如何启动的！</li><li>/proc/cpuinfo<br>　　本机的 CPU 的相关资讯，包含时脉、类型与运算功能等</li><li>/proc/devices<br>　　这个文件记录了系统各个主要装置的主要装置代号，与 mknod 有关呢！</li><li>/proc/dma<br>　　显示当前使用的d m a通道。</li><li>/proc/filesystems<br>　　目前系统已经加载的文件系统罗！</li><li>/proc/interrupts<br>　　目前系统上面的 IRQ 分配状态。</li><li>/proc/ioports<br>　　目前系统上面各个装置所配置的 I/O 位址。</li><li>/proc/kcore<br>　　这个就是内存的大小啦！好大对吧！但是不要读他啦！(系统物理内存映像。与物理内存大小完全一样，然而实际上没有占用这么多内存；它仅仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc 下没有任何东西占用任何磁盘空间。))</li><li>/proc/kmsg<br>　　核心输出的消息。也会被送到s y s l o g。</li><li>/proc/ksyms<br>　　核心符号表。</li><li>/proc/loadavg<br>　　系统“平均负载”;还记得 top 以及 uptime 吧？没错！上头的三个平均数值就是记录在此！</li><li>/proc/meminfo<br>　　各种存储器使用信息，包括物理内存和交换分区( s w a p )。使用 free 列出的内存资讯，嘿嘿！在这里也能够查阅到！    </li><li>/proc/modules<br>　　目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序啦！</li><li>/proc/mounts<br>　　系统已经挂载的数据，就是用 mount 这个命令呼叫出来的数据啦！</li><li>/proc/net<br>　　网络协议状态信息。</li><li>/proc/self<br>　　存放到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，这将会是不同的连接。这主要便于程序得到它自己的进程目录。</li><li>/proc/swaps<br>　　到底系统挂加载的内存在哪里？呵呵！使用掉的 partition 就记录在此啦！</li><li>/proc/stat<br>　　系统的不同状态，例如，系统启动后页面发生错误的次数。</li><li>/proc/partitions<br>　　使用 fdisk -l 会出现目前所有的 partition 吧？在这个文件当中也有纪录喔！</li><li>/proc/pci<br>　　在 PCI 汇流排上面，每个装置的详细情况！可用 lspci 来查阅！</li><li>/proc/uptime<br>　　就是用 uptime 的时候，会出现的资讯啦！</li><li>/proc/version<br>　　核心的版本，就是用 uname -a 显示的内容啦！</li><li>/proc/bus/*<br>　　一些汇流排的装置，还有 U盘 的装置也记录在此喔！</li></ol><hr><h2 id="usr："><a href="#usr：" class="headerlink" title="/usr："></a>/usr：</h2><pre><code>/usr 文件系统经常很大，因为所有程序安装在这里. /usr里的所有文件一般来自Linux distribution；本地安装的程序和其他东西在/usr/local 下.这样可能在升级新版系统或新distribution时无须重新安装全部程序./usr目录下的许多内容是可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的配置文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。</code></pre><ol><li>/usr/x11r6<br>　　包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x win d o w系统感到束手无策了。</li><li>/usr/x386<br>　　类似/ u s r / x 11r6 ，但是是专门给x 11 release 5的。</li><li>/usr/etc<br>　　存放设置文件</li><li>/usr/games<br>　　存放游戏和教学文件</li><li>/usr/include<br>　　存放C开发工具的头文件</li><li>/usr/share<br>　　存放结构独立的数据</li><li>/usr/bin<br>　　几乎所有用户命令.有些命令在/bin 或/usr/local/bin 中.</li><li>/usr/sbin<br>　　根文件系统不必要的系统管理命令，例如多数服务程序.  </li><li>/usr/share/man , /usr/share/info , /usr/share/doc<br>　　手册页、GNU信息文档和各种其他文档文件.  每个联机手册的“节”都有两个子目录。例如： / u s r / m a n / m a n 1中包含联机手册第一节的源码(没有格式化的原始文件)，/ u s r / m a n / c a t 1包含第一节已格式化的内容。l联机手册分为以下九节：内部命令、系统调用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。</li><li>/usr/include<br>　　包含了c语言的头文件，这些文件多以. h结尾，用来描述c语言程序中用到的数据结构、子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这个名字。</li><li>/usr/lib<br>　　程序或子系统的不变的数据文件，包括一些site-wide配置文件.名字lib来源于库(library); 编程的原始库存在/usr/lib 里.  当编译程序时，程序便会和其中的库进行连接。也有许多程序把配置文件存入其中。</li><li>/usr/local<br>　　本地安装的软件和其他文件放在这里. 这与/ u s r很相似。用户可能会在这发现一些比较大的软件包，如t e x、e m a c s等。 </li><li>/usr/src<br>　　存放程序的源代码</li></ol><hr><h2 id="var："><a href="#var：" class="headerlink" title="/var："></a>/var：</h2><pre><code>/var 包括系统一般运行时要改变的数据.通常这些数据所在的目录的大小是要经常变化或扩充的。原来/var 目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那些需要经常改变的目录放到/var中了.每个系统是特定的，即不通过网络与其他计算机共享。下面列出一些重要的目录(一些不太重要的目录省略了)。</code></pre><ol><li>/var/catman<br>　　当要求格式化时的man页的cache.man页的源文件一般存在/usr/man/man* 中；有些man页可能有预格式化的版本，存在/usr/man/cat* 中.而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了. (/var/catman 经常被清除，就象清除临时目录一样.)  </li><li>/var/lib<br>　　系统正常运行时要改变的文件.  </li><li>/var/local<br>　　/usr/local 中安装的程序的可变数据(即系统管理员安装的程序).注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock .  </li><li>/var/lock<br>　　锁定文件.许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件.其他程序注意到这个锁定文件，将不试图使用这个设备或文件.  </li><li>/var/log<br>　　各种程序的Log文件，特别是login  (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除.  </li><li>/var/run<br>　　保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息.</li><li>/var/spool<br>　　放置“假脱机( s p o o l )”程序的目录.mail, news, 打印队列和其他队列工作的目录.每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中.  </li><li>/var/tmp<br>　　比/tmp 允许的大或需要存在较长时间的临时文件. (虽然系统管理员可能不允许/var/tmp 有很旧的文件.) </li></ol><hr><h2 id="比较重要的目录"><a href="#比较重要的目录" class="headerlink" title="比较重要的目录"></a>比较重要的目录</h2><p>在 Linux 系统中，有几个目录是特别需要注意的，以下提供几个需要注意的目录，以及预设相关的用途：　<br>        /etc： 这个目录相当重要，如前所述，你的开机与系统数据文件均在这个目录之下，因此当这个目录被破坏，那你的系统大概也就差不多该死掉了！而在往后的文件中，你会发现我们常常使用这个目录下的 /etc/rc.d/init.d 这个子目录，因为这个 init.d 子目录是开启一些 Linux 系统服务的 scripts （可以想成是批次檔 ）的地方。而在 /etc/rc.d/rc.local 这个文件是开机的执行档。　<br>        /bin, /sbin, /usr/bin, /usr/sbin： 这是系统预设的执行文件的放置目录，例如 root 常常使用的 userconf, netconf, perl, gcc, c++ 等等的数据都放在这几个目录中，所以如果你在提示字符下找不到某个执行档时，可以在这四个目录中查一查！其中， /bin, /usr/bin 是给系统使用者使用的指令，而 /sbin, /usr/sbin 则是给系统管理员使用的指令！  　<br>        /usr/local： 这是系统预设的让你安装你后来升级的套件的目录。例如，当你发现有更新的 Web 套件（如 Apache ）可以安装，而你又不想以 rpm 的方式升级你的套件，则你可以将 apache 这个套件安装在 /usr/local 底下。安装在这里有个好处，因为目前大家的系统都是差不多的，所以如果你的系统要让别人接管的话，也比较容易上手呀！也比较容易找的到数据喔！因此，如果你有需要的话，通常我都会将 /usr/local/bin 这个路径加到我的 path 中。　<br>        /home： 这个是系统将有账号的人口的家目录设置的地方。    　<br>        /var： 这个路径就重要了！不论是登入、各类服务的问题发生时的记录、以及常态性的服务记录等等的记录目录，所以当你的系统有问题时，就需要来这个目录记录的文件数据中察看问题的所在啰！而 mail 的预设放置也是在这里，所以他是很重要的    　<br>        /usr/share/man, /usr/local/man： 这两个目录为放置各类套件说明档的地方，例如你如果执行 man man，则系统会自动去找这两个目录下的所有说明文件</p><h2 id="文件种类："><a href="#文件种类：" class="headerlink" title="文件种类："></a>文件种类：</h2><p>谈完了文件格式之后，再来谈谈所谓的文件种类吧！我们在刚刚的属性介绍中提到了最前面的标志 ( d 或 - ) 可以代表目录或文件，那就是不同的文件种类啦！Linux 的文件种类主要有底下</p><p>这几种：<br>    正规文件( regular file )：就是一般类型的文件，在由 ls –al 所显示出来的属性方面，第一个属性为 [ - ]。另外，依照文件的内容，又大略可以分为两种文件种类：<br>     纯文字文件(ascii) ：这是 Unix 系统中最多的一种啰，几乎只要我们可以用来做为设定的文件都属于这一种；<br>     二进制文件(binary) ：通常执行档除了 scripts （文字型批次文件）之外，就是这一种文件格式；<br>    目录 (directory)：就是目录！第一个属性为 [ d ]；<br>    连结档 (link)：就是类似 Windows 底下的快捷方式啦！第一个属性为 [ l ]；<br>    设备档 (device)：与系统周边相关的一些文件，通常都集中在 /dev 这个目录之下！通常又分为两种：<br>    区块 (block) 设备档 ：就是一些储存数据，以提供系统存取的接口设备，简单的说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的文件啦！第一个属性为 [ b ]；<br>    字符 (character) 设备档 ：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 [ c ]。</p><h2 id="Linux-的文件系统-inode-："><a href="#Linux-的文件系统-inode-：" class="headerlink" title="Linux 的文件系统( inode )："></a>Linux 的文件系统( inode )：</h2><p>在 Linux 系统当中，每个文件不止有文件的内容数据，还包括文件的种种属性，例如：所属群组、所属使用者、能否执行、文</p><p>件建立时间、文件特殊属性等等。我们将每个文件的内容分为两个部分来储存，一个是文件的属性，另一个则是文件的内容。<br>　<br>为了应付这两个不同的咚咚，所以 ext2 规划出 inode 与 Block 来分别储存文件的属性( 放在 inode 当中 )与文件的内容( 放置在 Block area 当中 )。当我们要将一个 partition 格式化</p><p>( format )为 ext2 时，就必须要指定 inode 与 Block 的大小才行，也就是说，当 partition 被格式化为 ext2 的文件系统时，他一定会有 inode table 与 block area 这两个区域。<br>　<br>Block 已经在前面说过了，他是数据储存的最小单位。那么 inode 是什么？！简单的说， Block 是记录『文件内容数据』的区域，至于 inode 则是记录『该文件的相关属性，以及文件内容</p><p>放置在哪一个 Block 之内』的信息。简单的说， inode 除了记录文件的属性外，同时还必须要具有指向( pointer )的功能，亦即指向文件内容放置的区块之中，好让操作系统可以正确的去</p><p>取得文件的内容啊</p><pre><code>该文件的拥有者与群组(owner/group)；该文件的存取模式；该文件的类型；该文件的建立日期(ctime)、最近一次的读取时间(atime)、最近修改的时间 (mtime)；该文件的容量；定义文件特性的旗标(flag)，如 SetUID...；该文件真正内容的指向 (pointer)；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux目录结构&quot;&gt;&lt;a href=&quot;#Linux目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux目录结构&quot;&gt;&lt;/a&gt;Linux目录结构&lt;/h1&gt;&lt;p&gt;【常见目录说明】&lt;/p&gt;
&lt;blockquote&gt;
&lt;table&gt;
&lt;thead&gt;

      
    
    </summary>
    
      <category term="OS" scheme="http://oleaster.cn/categories/OS/"/>
    
    
      <category term="Linux" scheme="http://oleaster.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SSH原理与运用（三）免密码登录详解</title>
    <link href="http://oleaster.cn/2018/02/03/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%953/"/>
    <id>http://oleaster.cn/2018/02/03/SSH远程登录3/</id>
    <published>2018-02-03T02:46:12.000Z</published>
    <updated>2018-03-26T10:45:14.522Z</updated>
    
    <content type="html"><![CDATA[<p><strong> SSH免密码登录详解 </strong></p><hr><p>为了更好的理解SSH免密码登录原理，我们先来说说SSH的安全验证，SSH采用的是”非对称密钥系统”，即耳熟能详的公钥私钥加密系统，其安全验证又分为两种级别。</p><h1 id="1-基于口令的安全验证"><a href="#1-基于口令的安全验证" class="headerlink" title="1. 基于口令的安全验证"></a>1. 基于口令的安全验证</h1><p>这种方式使用用户名密码进行联机登录，一般情况下我们使用的都是这种方式。整个过程大致如下：</p><p>（1）客户端发起连接请求。</p><p>（2）远程主机收到用户的登录请求，把自己的公钥发给客户端。</p><p>（3）客户端接收远程主机的公钥，然后使用远程主机的公钥加密登录密码，紧接着将加密后的登录密码连同自己的公钥一并发送给远程主机。</p><p>（4）远程主机接收客户端的公钥及加密后的登录密码，用自己的私钥解密收到的登录密码，如果密码正确则允许登录，到此为止双方彼此拥有了对方的公钥，开始双向加密解密。</p><p>PS：当网络中有另一台冒牌服务器冒充远程主机时，客户端的连接请求被服务器B拦截，服务器B将自己的公钥发送给客户端，客户端就会将密码加密后发送给冒牌服务器，冒牌服务器就可以拿自己的私钥获取到密码，然后为所欲为。因此当第一次链接远程主机时，在上述步骤的第（3）步中，会提示您当前远程主机的”公钥指纹”，以确认远程主机是否是正版的远程主机，如果选择继续后就可以输入密码进行登录了，当远程的主机接受以后，该台服务器的公钥就会保存到 ~/.ssh/known_hosts文件中。</p><h1 id="2-基于密匙的安全验证"><a href="#2-基于密匙的安全验证" class="headerlink" title="2. 基于密匙的安全验证"></a>2. 基于密匙的安全验证</h1><p>这种方式你需要在当前用户家目录下为自己创建一对密匙，并把公匙放在需要登录的服务器上。当你要连接到服务器上时，客户端就会向服务器请求使用密匙进行安全验证。服务器收到请求之后，会在该服务器上你所请求登录的用户的家目录下寻找你的公匙，然后与你发送过来的公匙进行比较。如果两个密匙一致，服务器就用该公匙加密“质询”并把它发送给客户端。客户端收到“质询”之后用自己的私匙解密再把它发送给服务器。与第一种级别相比，第二种级别不需要在网络上传送口令。</p><p>PS：简单来说，就是将客户端的公钥放到服务器上，那么客户端就可以免密码登录服务器了，那么客户端的公钥应该放到服务器上哪个地方呢？默认为你要登录的用户的家目录下的 .ssh 目录下的 authorized_keys 文件中（即：~/.ssh/authorized_keys）。</p><h1 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h1><p>rsync自动备份时免密码登录，集群环境中需要主机间互相通信如：Hadoop，目前小编只涉及到这两处，日后有其它地方用到再来补充~</p><h1 id="4-相关配置项"><a href="#4-相关配置项" class="headerlink" title="4. 相关配置项"></a>4. 相关配置项</h1><p>SSHD服务的配置文件位于/etc/ssh/sshd_config</p><p>配置项一：PubkeyAuthentication 是否允许使用密钥验证方式登录</p><p>配置项二：AuthorizedKeysFile允许登录主机的公钥存放文件，默认为用户家目录下的 .ssh/authorized_keys</p><h1 id="5-权限问题"><a href="#5-权限问题" class="headerlink" title="5. 权限问题"></a>5. 权限问题</h1><p>.ssh文件夹 700 chmod 700 .ssh</p><p>authorized_keys文件 644 chmod 644 .ssh/authorized_keys</p><h1 id="6-配置实现"><a href="#6-配置实现" class="headerlink" title="6. 配置实现"></a>6. 配置实现</h1><p>服务器：192.168.0.10 用户：server</p><p>客户端：192.168.0.11 用户：client</p><blockquote><p># 客户端配置<br># 使用client用户登录并进入家目录<br># cd /home/client<br># 建立认证公钥和私钥<br># ssh-keygen -t rsa （会有提示输入密码，直接回车即可）<br># 之后会在家目录下建立 .ssh 文件夹，内有id_rsa（私钥）和id_rsa.pub（公钥）两个文件<br># 将公钥文件上传到服务器上server的家目录<br># scp ~/.ssh/id_rsa.pub <a href="mailto:server@192.168.0.10" target="_blank" rel="noopener">server@192.168.0.10</a>:~</p></blockquote><blockquote><p># 服务器端配置<br># 使用server用户登录并进入家目录<br># cd /home/server<br># 建立 .ssh 文件夹<br># mkdir .ssh;<br># 修改文件夹权限<br># chmod 700 .ssh<br># 将客户端传过来的id_rsa.pub文件中的内容加入到authorized_keys中<br># cat id_rsa.pub &gt;&gt; .ssh/authorized_keys<br># chmod 644 .ssh/authorized_keys</p></blockquote><p>之后你从客户端使用 client 用户登录服务器的server用户时就不需要再输入密码了，但是第一次连接时还是会提示你进行远程主机公钥指纹核对并将其存入 ~/.ssh/known_hosts 文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; SSH免密码登录详解 &lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了更好的理解SSH免密码登录原理，我们先来说说SSH的安全验证，SSH采用的是”非对称密钥系统”，即耳熟能详的公钥私钥加密系统，其安全验证又分为两种级别。&lt;/p&gt;
&lt;h1 id=&quot;1-基于
      
    
    </summary>
    
      <category term="OS" scheme="http://oleaster.cn/categories/OS/"/>
    
    
      <category term="SSH" scheme="http://oleaster.cn/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>SSH原理与运用（二）远程操作与端口转发</title>
    <link href="http://oleaster.cn/2018/02/02/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%952/"/>
    <id>http://oleaster.cn/2018/02/02/SSH远程登录2/</id>
    <published>2018-02-02T02:46:12.000Z</published>
    <updated>2018-03-26T10:45:03.650Z</updated>
    
    <content type="html"><![CDATA[<p><strong> SSH远程操作与端口转发 </strong></p><hr><h1 id="七、远程操作"><a href="#七、远程操作" class="headerlink" title="七、远程操作"></a>七、远程操作</h1><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。<br>上一节的操作，就是一个例子：</p><blockquote><p>$ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p></blockquote><p>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。<br>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。</p><p>下面看几个例子。<br>【例1】<br>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。</p><blockquote><p>$ cd &amp;&amp; tar czv src | ssh user@host ‘tar xz’</p></blockquote><p>【例2】<br>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。</p><blockquote><p>$ ssh user@host ‘tar cz src’ | tar xzv</p></blockquote><p>【例3】<br>查看远程主机是否运行进程httpd。</p><blockquote><p>$ ssh user@host ‘ps ax | grep [h]ttpd’</p></blockquote><h1 id="八、绑定本地端口"><a href="#八、绑定本地端口" class="headerlink" title="八、绑定本地端口"></a>八、绑定本地端口</h1><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：</p><blockquote><p>$ ssh -D 8080 user@host</p></blockquote><p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><h1 id="九、本地端口转发"><a href="#九、本地端口转发" class="headerlink" title="九、本地端口转发"></a>九、本地端口转发</h1><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。<br>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>我们在host1执行下面的命令：</p><blockquote><p>$ ssh -L 2121:host2:21 host3</p></blockquote><p>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。<br>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。</p><blockquote><p>$ ftp localhost:2121</p></blockquote><p>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。<br>下面是一个比较有趣的例子。</p><blockquote><p>$ ssh -L 5900:localhost:5900 host3</p></blockquote><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。<br>另一个例子是通过host3的端口转发，ssh登录host2。</p><blockquote><p>$ ssh -L 9001:host2:22 host3</p></blockquote><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。</p><blockquote><p>$ ssh -p 9001 localhost</p></blockquote><p>上面的-p参数表示指定登录端口。</p><h1 id="十、远程端口转发"><a href="#十、远程端口转发" class="headerlink" title="十、远程端口转发"></a>十、远程端口转发</h1><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。<br>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？<br>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。<br>我们在host3执行下面的命令：</p><blockquote><p>$ ssh -R 2121:host2:21 host1</p></blockquote><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>绑定之后，我们在host1就可以连接host2了：</p><blockquote><p>$ ftp localhost:2121</p></blockquote><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p><h1 id="十一、SSH的其他参数"><a href="#十一、SSH的其他参数" class="headerlink" title="十一、SSH的其他参数"></a>十一、SSH的其他参数</h1><p>SSH还有一些别的参数，也值得介绍。<br>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p><blockquote><p>$ ssh -NT -D 8080 host</p></blockquote><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p><blockquote><p>$ ssh -f -D 8080 host</p></blockquote><p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p><p>十二、参考文献<br>   <a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a><br>   <a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; SSH远程操作与端口转发 &lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;七、远程操作&quot;&gt;&lt;a href=&quot;#七、远程操作&quot; class=&quot;headerlink&quot; title=&quot;七、远程操作&quot;&gt;&lt;/a&gt;七、远程操作&lt;/h1&gt;&lt;p&gt;SSH不仅可以用于远
      
    
    </summary>
    
      <category term="OS" scheme="http://oleaster.cn/categories/OS/"/>
    
    
      <category term="SSH" scheme="http://oleaster.cn/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>SSH原理与运用（一）远程登录</title>
    <link href="http://oleaster.cn/2018/02/01/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%951/"/>
    <id>http://oleaster.cn/2018/02/01/SSH远程登录1/</id>
    <published>2018-02-01T02:46:12.000Z</published>
    <updated>2018-03-26T10:44:56.212Z</updated>
    
    <content type="html"><![CDATA[<p><strong> SSH介绍 </strong> </p><blockquote><p>SSH是每一台Linux电脑的标准配置。<br>随着Linux设备从电脑逐渐扩展到手机、外设和家用电器，SSH的使用范围也越来越广。不仅程序员离不开它，很多普通用户也每天使用。<br>SSH具备多种功能，可以用于很多场合。有些事情，没有它就是办不成。本文是我的学习笔记，总结和解释了SSH的常见用法，希望对大家有用。<br>虽然本文内容只涉及初级应用，较为简单，但是需要读者具备最基本的”Shell知识”和了解”公钥加密”的概念。如果你对它们不熟悉，我推荐先阅读《UNIX / Linux 初学者教程》和《数字签名是什么？》。</p></blockquote><hr><h1 id="SSH原理与运用"><a href="#SSH原理与运用" class="headerlink" title="SSH原理与运用"></a>SSH原理与运用</h1><h2 id="一、什么是SSH？"><a href="#一、什么是SSH？" class="headerlink" title="一、什么是SSH？"></a>一、什么是SSH？</h2><blockquote><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。<br>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。<br>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。<br>此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p></blockquote><h2 id="二、最基本的用法"><a href="#二、最基本的用法" class="headerlink" title="二、最基本的用法"></a>二、最基本的用法</h2><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p><blockquote><p>$ ssh user@host</p></blockquote><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p><blockquote><p>$ ssh host</p></blockquote><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><blockquote><p>$ ssh -p 2222 user@host<br>上面这条命令表示，ssh直接连接远程主机的2222端口。</p></blockquote><h2 id="三、中间人攻击"><a href="#三、中间人攻击" class="headerlink" title="三、中间人攻击"></a>三、中间人攻击</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。<br>SSH协议是如何应对的呢？</p><h2 id="四、口令登录"><a href="#四、口令登录" class="headerlink" title="四、口令登录"></a>四、口令登录</h2><p>如果你是第一次登录对方主机，系统会出现下面的提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p><blockquote><p>Are you sure you want to continue connecting (yes/no)? yes</p></blockquote><p>系统会出现一句提示，表示host主机已经得到认可。</p><blockquote><p>Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.</p></blockquote><p>然后，会要求输入密码。</p><blockquote><p>Password: (enter password)</p></blockquote><p>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h2 id="五、公钥登录"><a href="#五、公钥登录" class="headerlink" title="五、公钥登录"></a>五、公钥登录</h2><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p><blockquote><p>$ ssh-keygen</p></blockquote><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。<br>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：</p><blockquote><p>$ ssh-copy-id user@host</p></blockquote><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　RSAAuthentication yes</span><br><span class="line">　　PubkeyAuthentication yes</span><br><span class="line">　　AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>然后，重启远程主机的ssh服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// ubuntu系统</span><br><span class="line">　　service ssh restart</span><br><span class="line">　　// debian系统</span><br><span class="line">　　/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></p><h2 id="六、authorized-keys文件"><a href="#六、authorized-keys文件" class="headerlink" title="六、authorized_keys文件"></a>六、authorized_keys文件</h2><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p><p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p><blockquote><p>$ ssh user@host ‘mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p></blockquote><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt; SSH介绍 &lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SSH是每一台Linux电脑的标准配置。&lt;br&gt;随着Linux设备从电脑逐渐扩展到手机、外设和家用电器，SSH的使用范围也越来越广。不仅程序员离不开它，很多普通用户也每天使用。&lt;br
      
    
    </summary>
    
      <category term="OS" scheme="http://oleaster.cn/categories/OS/"/>
    
    
      <category term="SSH" scheme="http://oleaster.cn/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Certbot免费https证书</title>
    <link href="http://oleaster.cn/2018/01/10/https%E8%AF%81%E4%B9%A6/"/>
    <id>http://oleaster.cn/2018/01/10/https证书/</id>
    <published>2018-01-10T02:46:12.000Z</published>
    <updated>2018-03-21T09:30:05.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Certbot免费https证书"><a href="#Certbot免费https证书" class="headerlink" title="Certbot免费https证书"></a>Certbot免费https证书</h1><hr><p>Certbot 的官方网站是 <a href="https://certbot.eff.org/" target="_blank" rel="noopener">https://certbot.eff.org/</a></p><blockquote><p>当前工作目录为 /root</p></blockquote><h2 id="1-获取certbot"><a href="#1-获取certbot" class="headerlink" title="1.获取certbot"></a>1.获取certbot</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br><span class="line">./certbot-auto</span><br></pre></td></tr></table></figure></code></pre><blockquote><p><em>执行自动安装会下载和安装需要的环境组件等，总之我们执行就可以，遇到需要安装与否的输入y后回车。</em></p></blockquote><h2 id="2-停止nginx"><a href="#2-停止nginx" class="headerlink" title="2.停止nginx"></a>2.停止nginx</h2><blockquote><p>service nginx stop</p></blockquote><h2 id="3-生成证书"><a href="#3-生成证书" class="headerlink" title="3.生成证书"></a>3.生成证书</h2><blockquote><p>(如果后期生成报错,先删除原有certbot-auto,按第一步重新下载certbot即可)<br>申请证书有两种验证方式，<br>一种是standalone，这种验证方式虽然也可以部署后，但是以后更新证书的时候需要重启 web 服务器；<br>第二种是webroot，就是在网站根目录下生成一个文件，通过访问该文件来验证，不需要重启 web 服务器。<br>第一种命令：./certbot-auto certonly –standalone -d example.com -d <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>第二种命令：./certbot-auto certonly –webroot -w /var/www/example -d example.com -d <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> -w /var/www/baidu -d baidu.com -d <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br><em>（/var/www/example是网站的目录）使用-d追加多个域名</em><br>A - 单域名<br>./certbot-auto certonly –email <a href="mailto:admin@qq.com" target="_blank" rel="noopener">admin@qq.com</a> –agree-tos –webroot -w /var/www/example -d <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a><br>B - 多域名<br>./certbot-auto certonly –email <a href="mailto:admin@qq.com" target="_blank" rel="noopener">admin@qq.com</a> –agree-tos –webroot -w /var/www/example -d example.com -d <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> -w /var/www/example1 -d example1.com -d <a href="http://www.example1.com" target="_blank" rel="noopener">www.example1.com</a></p></blockquote><h2 id="4-查看生成的证书"><a href="#4-查看生成的证书" class="headerlink" title="4.查看生成的证书"></a>4.查看生成的证书</h2><blockquote><p>ls /etc/letsencrypt/live/<br>我们可以在上面生成完成看到证书被放到/etc/letsencrypt/live/example/目录中，这个我们根据自己网址的文档区别。里面可以看到有cert.pem 、chain.pem 、 fullchain.pem  、privkey.pem四个文件。</p></blockquote><h2 id="5-在nginx配置证书"><a href="#5-在nginx配置证书" class="headerlink" title="5.在nginx配置证书"></a>5.在nginx配置证书</h2><blockquote><p>ssl_certificate /etc/letsencrypt/live/cdw.me/fullchain.pem;#证书位置<br> ssl_certificate_key /etc/letsencrypt/live/cdw.me/privkey.pem;# 私钥位置<br>在Nginx站点配置文件中添加443端口server，然后设置SSL证书文件。设置后重启nginx看看是否成功，如果错误会有提示的。最后收尾工作，我们是否需要将所有的非HTTP跳转到HTTPS。</p></blockquote><h2 id="6-启动nginx"><a href="#6-启动nginx" class="headerlink" title="6.启动nginx"></a>6.启动nginx</h2><blockquote><p>service nginx start</p></blockquote><hr><ol><li><p>编写更新脚本renew-cert.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 停止nginx</span><br><span class="line">service nginx stop</span><br><span class="line"># 续签</span><br><span class="line"># --force-renew 强制更新</span><br><span class="line">/root/certbot-auto renew --force-renew </span><br><span class="line"># 启动nginx</span><br><span class="line">service nginx start</span><br></pre></td></tr></table></figure></li><li><p>a+x renew-cert.sh</p></li><li><p>自动更新https证书(crontab)</p><blockquote><p>crontab -l  定时任务列表<br>crontab -u root -e (-u root 表示哪个用户的定时任务)<br>添加: * * * * /3 * ./renew-cert.sh (表示每3个月执行一次)<br>在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下：<br>minute hour day-of-month month-of-year day-of-week commands<br>合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday)<br><code>除了数字还有几个个特殊的符号就是&quot;*&quot;、&quot;/&quot;和&quot;-&quot;、&quot;,&quot;，*代表所有的取值范围内的数字，&quot;/&quot;代表每的意思,&quot;/5&quot;表示每5个单位，&quot;-&quot;代表从某个数字到某个数字,&quot;,&quot;分开几个离散的数字。</code><br>或者手动 ./certbot-auto renew –dry-run</p></blockquote></li></ol><hr><p><strong>Let’s Encrypt 生成的免费证书为3个月时间，但是我们可以无限次续签证书</strong></p><hr><p>补充说明:<br>密钥对,公钥,证书,私钥,jks,keystore,truststore,cer,pfx名词说明<br><strong>密钥:</strong><br>我理解是公钥+私钥的统称。</p><p><strong>密钥对：</strong><br>公钥(证书)和私钥成对存在。通信双方各持有自己的私钥和对方的公钥。自己的私钥需密切保护，而公钥是公开给对方的。在windows下，单独存在的公钥一般是后缀为.cer的文件<br>A用自己的私钥对数据加密，发给B，B用A提供的公钥解密。同理B用自己的私钥对数据加密，发送给A后，A用B的公钥解开。<br>公钥的两个用途：<br>1。验证对方身份：防止其他人假冒对方发送数据给你。<br>2。解密。<br>私钥的两个用途：<br>1。表明自己身份：除非第三方有你私钥，否则无法假冒你发送数据数据给对方。<br>2。加密。</p><p><strong>jks(Java key store)：</strong><br>java用的存储密钥的容器。可以同时容纳n个公钥或私钥，后缀一般是.jks或者.keystore或.truststore等，千奇百怪。不管什么后缀，它就是一个容器，各个公司或机构叫法不同而已。比如把只包含”受信任的公钥”的容器存成.truststore文件等。<br>用jdk\bin目录下的keytool.exe对其进行查看，导入，导出，删除，修改密码等各种操作。可以对jks容器加密码，输入正确才可以操作此容器中密钥。还有一个密码的概念与上者不同，是jks中存储着的私钥的密码，通常是绝密的。意思就是一个keystore(.jks)文件通常里面会装有公钥和私钥，keystore本身有一个密码，输入这个密码可以导出公钥为cer文件，而还有一个私钥是看不到的，想看私钥要输入另一个密码。意思是这样，不一定有x相应的命令对应。</p><p><strong>pfx：</strong><br>和jks功能相同但文件格式不同，pfx是浏览器用的。<br>可以用一些工具程序把pfx转化成jks格式供java程序使用(如银行只提供了pfx，但是我们想用httpclient模拟浏览器自动访问时)。据说IE导出的pfx格式不标准，转化jks时往往报错，可以尝试用Netscape Navigator导入再导出，然后再转化。碰到过这样的情况。<br>常见的几种https系统的访问。经https协议的数据经过加密传输，防止第三方监听，冒充和篡改。<br>1.不需要用户做任何操作，比如<a href="https://www.verisign.com/" target="_blank" rel="noopener">https://www.verisign.com/</a><br>这是因为此公钥是合法的(公钥是可信任的机构颁发，和实际域名吻合，而且没有到期)。用IE访问时空白处点右键可以查看公钥信息。<br>2.https的页面会弹出公钥确认提示<br>公钥不合法(不是可信任的机构颁发，和实际域名不吻合，已到期)，但用户点“是”即表示忽略危险，继续访问。<br>3.需要往浏览器倒入一个文件才可访问的<br>一般是银行在线交易等特别需要安全的场合，站方(银行)需要验证访客身份(如要确认必须是已注册的网银商户)，需要在浏览器中导入含有访客私钥的pfx文件。</p><p>生成jks：<br>在银行没有提供jks文件的情况下对帐，需要自己生成jks<br>对于1，2类https网站，如果java程序访问此地址时在jre默认的信任库中找不到对方证书的颁发机构，则会抛出安全方面的异常。所以要将站方公钥存进一个jks，并在环境变量中设定，表明信任此库中的公钥，才可以正常访问。<br>我是用现成的make_jks的工具类在程序中读取<a href="https://xxxx地址，程序自动抓取出银行公钥并存进一个jks文件。" target="_blank" rel="noopener">https://xxxx地址，程序自动抓取出银行公钥并存进一个jks文件。</a><br>在浏览器中查看站方公钥时，把公钥导出(一般是cer后缀)，然后用keytool.exe手工将此cer导入一个jks也可以<br>以上1，2类https网站，仅仅是用到了公钥的“验证对方身份”功能。对于第3种https网站，也可以找到现成的程序把pfx直接转成jks。既然动用了pfx，一般是把公钥的两个用途和私钥的两个用途都用起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Certbot免费https证书&quot;&gt;&lt;a href=&quot;#Certbot免费https证书&quot; class=&quot;headerlink&quot; title=&quot;Certbot免费https证书&quot;&gt;&lt;/a&gt;Certbot免费https证书&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;Certbot 的
      
    
    </summary>
    
      <category term="Web" scheme="http://oleaster.cn/categories/Web/"/>
    
    
      <category term="HTTP" scheme="http://oleaster.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>这是一个标题</title>
    <link href="http://oleaster.cn/2018/01/08/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/"/>
    <id>http://oleaster.cn/2018/01/08/文章标题/</id>
    <published>2018-01-08T02:46:12.000Z</published>
    <updated>2018-03-21T09:28:27.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo" title="">                </div>                <div class="image-caption">cmd-markdown-logo</div>            </figure><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor" title="">                </div>                <div class="image-caption">tool-editor</div>            </figure><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager" title="">                </div>                <div class="image-caption">tool-manager</div>            </figure><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager" title="">                </div>                <div class="image-caption">tool-manager</div>            </figure><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list" title="">                </div>                <div class="image-caption">file-list</div>            </figure><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欢迎使用-Cmd-Markdown-编辑阅读器&quot;&gt;&lt;a href=&quot;#欢迎使用-Cmd-Markdown-编辑阅读器&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用 Cmd Markdown 编辑阅读器&quot;&gt;&lt;/a&gt;欢迎使用 Cmd Markdown
      
    
    </summary>
    
      <category term="Sundry" scheme="http://oleaster.cn/categories/Sundry/"/>
    
    
      <category term="Trial" scheme="http://oleaster.cn/tags/Trial/"/>
    
  </entry>
  
</feed>
